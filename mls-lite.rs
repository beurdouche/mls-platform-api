/* automatically generated by rust-bindgen 0.69.2 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC2X: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 37;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C2X: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const __bool_true_false_are_defined: u32 = 1;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ApplicationIdExt {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  Application specific identifier.\n\n  A custom application level identifier that can be optionally stored\n  within the `leaf_node_extensions` of a group [Member](crate::group::Member)."]
pub type ApplicationIdExt_t = ApplicationIdExt;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn application_id_ext_clone(x: *const ApplicationIdExt_t) -> *mut ApplicationIdExt_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn application_id_ext_free(_x: *mut ApplicationIdExt_t);
}
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Default, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[test]
fn bindgen_test_layout_max_align_t() {
    const UNINIT: ::std::mem::MaybeUninit<max_align_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<max_align_t>(),
        32usize,
        concat!("Size of: ", stringify!(max_align_t))
    );
    assert_eq!(
        ::std::mem::align_of::<max_align_t>(),
        16usize,
        concat!("Alignment of ", stringify!(max_align_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce1) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce1)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__clang_max_align_nonce2) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(max_align_t),
            "::",
            stringify!(__clang_max_align_nonce2)
        )
    );
}
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    const UNINIT: ::std::mem::MaybeUninit<__fsid_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__val) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_uint8 {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const u8,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_uint8() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_uint8> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_uint8>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_uint8))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_uint8>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_uint8))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_uint8),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_uint8),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_uint8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_uint8_t = slice_ref_uint8;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn application_id_ext_identifier(
        __safer_ffi_gen_self: *const ApplicationIdExt_t,
    ) -> slice_ref_uint8_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_uint8 {
    #[doc = " <No documentation available>"]
    pub ptr: *mut u8,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_uint8() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_uint8> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_uint8>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_uint8))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_uint8>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_uint8))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_uint8),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_uint8),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_uint8),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_uint8 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_uint8_t = Vec_uint8;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn application_id_ext_new(identifier: Vec_uint8_t) -> *mut ApplicationIdExt_t;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_ApplicationIdExt {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const ApplicationIdExt_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_ApplicationIdExt() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_ApplicationIdExt> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_ApplicationIdExt>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_ApplicationIdExt))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_ApplicationIdExt>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_ApplicationIdExt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_ApplicationIdExt),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_ApplicationIdExt),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_ApplicationIdExt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_ApplicationIdExt_t = slice_ref_ApplicationIdExt;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn application_id_ext_slice_get(
        items: slice_ref_ApplicationIdExt_t,
        index: usize,
    ) -> *const ApplicationIdExt_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_ApplicationIdExt {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut ApplicationIdExt_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_ApplicationIdExt() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_ApplicationIdExt> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_ApplicationIdExt>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_ApplicationIdExt))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_ApplicationIdExt>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_ApplicationIdExt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_ApplicationIdExt),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_ApplicationIdExt),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_ApplicationIdExt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_ApplicationIdExt_t = slice_mut_ApplicationIdExt;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn application_id_ext_slice_get_mut(
        items: slice_mut_ApplicationIdExt_t,
        index: usize,
    ) -> *mut ApplicationIdExt_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_ApplicationIdExt {
    #[doc = " <No documentation available>"]
    pub ptr: *mut ApplicationIdExt_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_ApplicationIdExt() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_ApplicationIdExt> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_ApplicationIdExt>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_ApplicationIdExt))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_ApplicationIdExt>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_ApplicationIdExt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ApplicationIdExt),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ApplicationIdExt),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ApplicationIdExt),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_ApplicationIdExt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_ApplicationIdExt_t = Vec_ApplicationIdExt;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn application_id_ext_vec_as_slice(
        v: *const Vec_ApplicationIdExt_t,
    ) -> slice_ref_ApplicationIdExt_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn application_id_ext_vec_as_slice_mut(
        v: *mut Vec_ApplicationIdExt_t,
    ) -> slice_mut_ApplicationIdExt_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn application_id_ext_vec_free(_v: Vec_ApplicationIdExt_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn application_id_ext_vec_new() -> Vec_ApplicationIdExt_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn application_id_ext_vec_push(
        v: *mut Vec_ApplicationIdExt_t,
        item: *mut ApplicationIdExt_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ApplicationMessageDescription {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  Description of a MLS application message."]
pub type ApplicationMessageDescription_t = ApplicationMessageDescription;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn application_message_description_clone(
        x: *const ApplicationMessageDescription_t,
    ) -> *mut ApplicationMessageDescription_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn application_message_description_data(
        __safer_ffi_gen_self: *const ApplicationMessageDescription_t,
    ) -> slice_ref_uint8_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn application_message_description_free(_x: *mut ApplicationMessageDescription_t);
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_ApplicationMessageDescription {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const ApplicationMessageDescription_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_ApplicationMessageDescription() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_ApplicationMessageDescription> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_ApplicationMessageDescription>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(slice_ref_ApplicationMessageDescription)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_ApplicationMessageDescription>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(slice_ref_ApplicationMessageDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_ApplicationMessageDescription),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_ApplicationMessageDescription),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_ApplicationMessageDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_ApplicationMessageDescription_t = slice_ref_ApplicationMessageDescription;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn application_message_description_slice_get(
        items: slice_ref_ApplicationMessageDescription_t,
        index: usize,
    ) -> *const ApplicationMessageDescription_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_ApplicationMessageDescription {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut ApplicationMessageDescription_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_ApplicationMessageDescription() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_ApplicationMessageDescription> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_ApplicationMessageDescription>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(slice_mut_ApplicationMessageDescription)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_ApplicationMessageDescription>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(slice_mut_ApplicationMessageDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_ApplicationMessageDescription),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_ApplicationMessageDescription),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_ApplicationMessageDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_ApplicationMessageDescription_t = slice_mut_ApplicationMessageDescription;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn application_message_description_slice_get_mut(
        items: slice_mut_ApplicationMessageDescription_t,
        index: usize,
    ) -> *mut ApplicationMessageDescription_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_ApplicationMessageDescription {
    #[doc = " <No documentation available>"]
    pub ptr: *mut ApplicationMessageDescription_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_ApplicationMessageDescription() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_ApplicationMessageDescription> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_ApplicationMessageDescription>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_ApplicationMessageDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_ApplicationMessageDescription>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(Vec_ApplicationMessageDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ApplicationMessageDescription),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ApplicationMessageDescription),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ApplicationMessageDescription),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_ApplicationMessageDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_ApplicationMessageDescription_t = Vec_ApplicationMessageDescription;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn application_message_description_vec_as_slice(
        v: *const Vec_ApplicationMessageDescription_t,
    ) -> slice_ref_ApplicationMessageDescription_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn application_message_description_vec_as_slice_mut(
        v: *mut Vec_ApplicationMessageDescription_t,
    ) -> slice_mut_ApplicationMessageDescription_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn application_message_description_vec_free(_v: Vec_ApplicationMessageDescription_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn application_message_description_vec_new() -> Vec_ApplicationMessageDescription_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn application_message_description_vec_push(
        v: *mut Vec_ApplicationMessageDescription_t,
        item: *mut ApplicationMessageDescription_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BasicCredential {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  Bare assertion of an identity without any additional information.\n\n  The format of the encoded identity is defined by the application.\n\n\n  # Warning\n\n  Basic credentials are inherently insecure since they can not be\n  properly validated. It is not recommended to use [`BasicCredential`]\n  in production applications."]
pub type BasicCredential_t = BasicCredential;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn basic_credential_clone(x: *const BasicCredential_t) -> *mut BasicCredential_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn basic_credential_free(_x: *mut BasicCredential_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn basic_credential_identifier(
        __safer_ffi_gen_self: *const BasicCredential_t,
    ) -> slice_ref_uint8_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn basic_credential_new(identifier: Vec_uint8_t) -> *mut BasicCredential_t;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_BasicCredential {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const BasicCredential_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_BasicCredential() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_BasicCredential> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_BasicCredential>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_BasicCredential))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_BasicCredential>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_BasicCredential))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_BasicCredential),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_BasicCredential),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_BasicCredential {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_BasicCredential_t = slice_ref_BasicCredential;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn basic_credential_slice_get(
        items: slice_ref_BasicCredential_t,
        index: usize,
    ) -> *const BasicCredential_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_BasicCredential {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut BasicCredential_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_BasicCredential() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_BasicCredential> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_BasicCredential>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_BasicCredential))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_BasicCredential>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_BasicCredential))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_BasicCredential),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_BasicCredential),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_BasicCredential {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_BasicCredential_t = slice_mut_BasicCredential;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn basic_credential_slice_get_mut(
        items: slice_mut_BasicCredential_t,
        index: usize,
    ) -> *mut BasicCredential_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_BasicCredential {
    #[doc = " <No documentation available>"]
    pub ptr: *mut BasicCredential_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_BasicCredential() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_BasicCredential> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_BasicCredential>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_BasicCredential))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_BasicCredential>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_BasicCredential))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_BasicCredential),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_BasicCredential),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_BasicCredential),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_BasicCredential {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_BasicCredential_t = Vec_BasicCredential;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn basic_credential_vec_as_slice(
        v: *const Vec_BasicCredential_t,
    ) -> slice_ref_BasicCredential_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn basic_credential_vec_as_slice_mut(
        v: *mut Vec_BasicCredential_t,
    ) -> slice_mut_BasicCredential_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn basic_credential_vec_free(_v: Vec_BasicCredential_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn basic_credential_vec_new() -> Vec_BasicCredential_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn basic_credential_vec_push(v: *mut Vec_BasicCredential_t, item: *mut BasicCredential_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Capabilities {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  Capabilities of a MLS client"]
pub type Capabilities_t = Capabilities;
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_uint16 {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const u16,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_uint16() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_uint16> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_uint16>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_uint16))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_uint16>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_uint16))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_uint16),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_uint16),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_uint16 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_uint16_t = slice_ref_uint16;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn capabilities_cipher_suites(
        __safer_ffi_gen_self: *const Capabilities_t,
    ) -> slice_ref_uint16_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn capabilities_clone(x: *const Capabilities_t) -> *mut Capabilities_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn capabilities_credentials(
        __safer_ffi_gen_self: *const Capabilities_t,
    ) -> slice_ref_uint16_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn capabilities_extensions(
        __safer_ffi_gen_self: *const Capabilities_t,
    ) -> slice_ref_uint16_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn capabilities_free(_x: *mut Capabilities_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn capabilities_proposals(
        __safer_ffi_gen_self: *const Capabilities_t,
    ) -> slice_ref_uint16_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn capabilities_protocol_versions(
        __safer_ffi_gen_self: *const Capabilities_t,
    ) -> slice_ref_uint16_t;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_Capabilities {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const Capabilities_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_Capabilities() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_Capabilities> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_Capabilities>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_Capabilities))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_Capabilities>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_Capabilities))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_Capabilities),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_Capabilities),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_Capabilities {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_Capabilities_t = slice_ref_Capabilities;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn capabilities_slice_get(
        items: slice_ref_Capabilities_t,
        index: usize,
    ) -> *const Capabilities_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_Capabilities {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut Capabilities_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_Capabilities() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_Capabilities> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_Capabilities>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_Capabilities))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_Capabilities>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_Capabilities))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_Capabilities),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_Capabilities),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_Capabilities {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_Capabilities_t = slice_mut_Capabilities;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn capabilities_slice_get_mut(
        items: slice_mut_Capabilities_t,
        index: usize,
    ) -> *mut Capabilities_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn capabilities_sorted(__safer_ffi_gen_self: *mut Capabilities_t) -> *mut Capabilities_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_Capabilities {
    #[doc = " <No documentation available>"]
    pub ptr: *mut Capabilities_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_Capabilities() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_Capabilities> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_Capabilities>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_Capabilities))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_Capabilities>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_Capabilities))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_Capabilities),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_Capabilities),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_Capabilities),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_Capabilities {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_Capabilities_t = Vec_Capabilities;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn capabilities_vec_as_slice(v: *const Vec_Capabilities_t) -> slice_ref_Capabilities_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn capabilities_vec_as_slice_mut(v: *mut Vec_Capabilities_t) -> slice_mut_Capabilities_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn capabilities_vec_free(_v: Vec_Capabilities_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn capabilities_vec_new() -> Vec_Capabilities_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn capabilities_vec_push(v: *mut Vec_Capabilities_t, item: *mut Capabilities_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CertificateChain {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  A chain of [`DerCertificate`] that is ordered from leaf to root.\n\n  Certificate chains MAY leave out root CA's so long as they are\n  provided as input to whatever certificate validator ultimately is\n  verifying the chain."]
pub type CertificateChain_t = CertificateChain;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn certificate_chain_clone(x: *const CertificateChain_t) -> *mut CertificateChain_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn certificate_chain_free(_x: *mut CertificateChain_t);
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_CertificateChain {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const CertificateChain_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_CertificateChain() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_CertificateChain> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_CertificateChain>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_CertificateChain))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_CertificateChain>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_CertificateChain))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_CertificateChain),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_CertificateChain),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_CertificateChain {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_CertificateChain_t = slice_ref_CertificateChain;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn certificate_chain_slice_get(
        items: slice_ref_CertificateChain_t,
        index: usize,
    ) -> *const CertificateChain_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_CertificateChain {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut CertificateChain_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_CertificateChain() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_CertificateChain> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_CertificateChain>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_CertificateChain))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_CertificateChain>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_CertificateChain))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_CertificateChain),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_CertificateChain),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_CertificateChain {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_CertificateChain_t = slice_mut_CertificateChain;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn certificate_chain_slice_get_mut(
        items: slice_mut_CertificateChain_t,
        index: usize,
    ) -> *mut CertificateChain_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_CertificateChain {
    #[doc = " <No documentation available>"]
    pub ptr: *mut CertificateChain_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_CertificateChain() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_CertificateChain> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_CertificateChain>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_CertificateChain))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_CertificateChain>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_CertificateChain))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_CertificateChain),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_CertificateChain),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_CertificateChain),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_CertificateChain {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_CertificateChain_t = Vec_CertificateChain;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn certificate_chain_vec_as_slice(
        v: *const Vec_CertificateChain_t,
    ) -> slice_ref_CertificateChain_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn certificate_chain_vec_as_slice_mut(
        v: *mut Vec_CertificateChain_t,
    ) -> slice_mut_CertificateChain_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn certificate_chain_vec_free(_v: Vec_CertificateChain_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn certificate_chain_vec_new() -> Vec_CertificateChain_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn certificate_chain_vec_push(
        v: *mut Vec_CertificateChain_t,
        item: *mut CertificateChain_t,
    );
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn cipher_suite_free(_x: u16);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CommitMessageDescription {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  Description of a processed MLS commit message."]
pub type CommitMessageDescription_t = CommitMessageDescription;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn commit_message_description_clone(
        x: *const CommitMessageDescription_t,
    ) -> *mut CommitMessageDescription_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn commit_message_description_free(_x: *mut CommitMessageDescription_t);
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_CommitMessageDescription {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const CommitMessageDescription_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_CommitMessageDescription() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_CommitMessageDescription> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_CommitMessageDescription>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_CommitMessageDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_CommitMessageDescription>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(slice_ref_CommitMessageDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_CommitMessageDescription),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_CommitMessageDescription),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_CommitMessageDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_CommitMessageDescription_t = slice_ref_CommitMessageDescription;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn commit_message_description_slice_get(
        items: slice_ref_CommitMessageDescription_t,
        index: usize,
    ) -> *const CommitMessageDescription_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_CommitMessageDescription {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut CommitMessageDescription_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_CommitMessageDescription() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_CommitMessageDescription> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_CommitMessageDescription>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_CommitMessageDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_CommitMessageDescription>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(slice_mut_CommitMessageDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_CommitMessageDescription),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_CommitMessageDescription),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_CommitMessageDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_CommitMessageDescription_t = slice_mut_CommitMessageDescription;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn commit_message_description_slice_get_mut(
        items: slice_mut_CommitMessageDescription_t,
        index: usize,
    ) -> *mut CommitMessageDescription_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_CommitMessageDescription {
    #[doc = " <No documentation available>"]
    pub ptr: *mut CommitMessageDescription_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_CommitMessageDescription() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_CommitMessageDescription> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_CommitMessageDescription>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_CommitMessageDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_CommitMessageDescription>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_CommitMessageDescription))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_CommitMessageDescription),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_CommitMessageDescription),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_CommitMessageDescription),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_CommitMessageDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_CommitMessageDescription_t = Vec_CommitMessageDescription;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn commit_message_description_vec_as_slice(
        v: *const Vec_CommitMessageDescription_t,
    ) -> slice_ref_CommitMessageDescription_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn commit_message_description_vec_as_slice_mut(
        v: *mut Vec_CommitMessageDescription_t,
    ) -> slice_mut_CommitMessageDescription_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn commit_message_description_vec_free(_v: Vec_CommitMessageDescription_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn commit_message_description_vec_new() -> Vec_CommitMessageDescription_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn commit_message_description_vec_push(
        v: *mut Vec_CommitMessageDescription_t,
        item: *mut CommitMessageDescription_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CommitOutput {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  Result of MLS commit operation using\n  [`Group::commit`](crate::group::Group::commit) or\n  [`CommitBuilder::build`](CommitBuilder::build)."]
pub type CommitOutput_t = CommitOutput;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn commit_output_clone(x: *const CommitOutput_t) -> *mut CommitOutput_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MlsMessage {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  A MLS protocol message for sending data over the wire."]
pub type MlsMessage_t = MlsMessage;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn commit_output_commit_message(
        __safer_ffi_gen_self: *const CommitOutput_t,
    ) -> *const MlsMessage_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn commit_output_external_commit_group_info(
        __safer_ffi_gen_self: *const CommitOutput_t,
    ) -> *const MlsMessage_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn commit_output_free(_x: *mut CommitOutput_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExportedTree {
    _unused: [u8; 0],
}
#[doc = " <No documentation available>"]
pub type ExportedTree_t = ExportedTree;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn commit_output_ratchet_tree(
        __safer_ffi_gen_self: *const CommitOutput_t,
    ) -> *const ExportedTree_t;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_CommitOutput {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const CommitOutput_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_CommitOutput() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_CommitOutput> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_CommitOutput>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_CommitOutput))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_CommitOutput>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_CommitOutput))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_CommitOutput),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_CommitOutput),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_CommitOutput {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_CommitOutput_t = slice_ref_CommitOutput;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn commit_output_slice_get(
        items: slice_ref_CommitOutput_t,
        index: usize,
    ) -> *const CommitOutput_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_CommitOutput {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut CommitOutput_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_CommitOutput() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_CommitOutput> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_CommitOutput>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_CommitOutput))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_CommitOutput>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_CommitOutput))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_CommitOutput),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_CommitOutput),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_CommitOutput {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_CommitOutput_t = slice_mut_CommitOutput;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn commit_output_slice_get_mut(
        items: slice_mut_CommitOutput_t,
        index: usize,
    ) -> *mut CommitOutput_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProposalInfo_Proposal {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  Proposal description used as input to a\n  [`MlsRules`](crate::MlsRules)."]
pub type ProposalInfo_Proposal_t = ProposalInfo_Proposal;
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_ProposalInfo_Proposal {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const ProposalInfo_Proposal_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_ProposalInfo_Proposal() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_ProposalInfo_Proposal> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_ProposalInfo_Proposal>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_ProposalInfo_Proposal))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_ProposalInfo_Proposal>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_ProposalInfo_Proposal))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_ProposalInfo_Proposal),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_ProposalInfo_Proposal),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_ProposalInfo_Proposal {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_ProposalInfo_Proposal_t = slice_ref_ProposalInfo_Proposal;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn commit_output_unused_proposals(
        __safer_ffi_gen_self: *const CommitOutput_t,
    ) -> slice_ref_ProposalInfo_Proposal_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_CommitOutput {
    #[doc = " <No documentation available>"]
    pub ptr: *mut CommitOutput_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_CommitOutput() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_CommitOutput> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_CommitOutput>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_CommitOutput))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_CommitOutput>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_CommitOutput))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_CommitOutput),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_CommitOutput),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_CommitOutput),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_CommitOutput {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_CommitOutput_t = Vec_CommitOutput;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn commit_output_vec_as_slice(v: *const Vec_CommitOutput_t) -> slice_ref_CommitOutput_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn commit_output_vec_as_slice_mut(v: *mut Vec_CommitOutput_t) -> slice_mut_CommitOutput_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn commit_output_vec_free(_v: Vec_CommitOutput_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn commit_output_vec_new() -> Vec_CommitOutput_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn commit_output_vec_push(v: *mut Vec_CommitOutput_t, item: *mut CommitOutput_t);
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_MlsMessage {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const MlsMessage_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_MlsMessage() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_MlsMessage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_MlsMessage>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_MlsMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_MlsMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_MlsMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_MlsMessage),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_MlsMessage),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_MlsMessage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_MlsMessage_t = slice_ref_MlsMessage;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn commit_output_welcome_messages(
        __safer_ffi_gen_self: *const CommitOutput_t,
    ) -> slice_ref_MlsMessage_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Credential {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  The layout of mls_rs_core::identity::credential::Credential is subject to change"]
pub type Credential_t = Credential;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn credential_clone(x: *const Credential_t) -> *mut Credential_t;
}
#[doc = " <No documentation available>"]
pub const CredentialDiscriminant_CREDENTIAL_DISCRIMINANT_BASIC: CredentialDiscriminant = 0;
#[doc = " <No documentation available>"]
pub const CredentialDiscriminant_CREDENTIAL_DISCRIMINANT_X509: CredentialDiscriminant = 1;
#[doc = " <No documentation available>"]
pub const CredentialDiscriminant_CREDENTIAL_DISCRIMINANT_CUSTOM: CredentialDiscriminant = 2;
pub type CredentialDiscriminant = ::std::os::raw::c_uint;
pub type CredentialDiscriminant_t = i32;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn credential_discriminant(x: *const Credential_t) -> CredentialDiscriminant_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn credential_free(_x: *mut Credential_t);
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_Credential {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const Credential_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_Credential() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_Credential> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_Credential>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_Credential))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_Credential>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_Credential))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_Credential),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_Credential),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_Credential {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_Credential_t = slice_ref_Credential;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn credential_slice_get(items: slice_ref_Credential_t, index: usize)
        -> *const Credential_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_Credential {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut Credential_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_Credential() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_Credential> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_Credential>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_Credential))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_Credential>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_Credential))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_Credential),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_Credential),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_Credential {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_Credential_t = slice_mut_Credential;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn credential_slice_get_mut(
        items: slice_mut_Credential_t,
        index: usize,
    ) -> *mut Credential_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn credential_to_basic(x: *const Credential_t) -> *const BasicCredential_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomCredential {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  Custom user created credential type.\n\n  # Warning\n\n  In order to use a custom credential within an MLS group, a supporting\n  [`IdentityProvider`](crate::identity::IdentityProvider) must be created that can\n  authenticate the credential."]
pub type CustomCredential_t = CustomCredential;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn credential_to_custom(x: *const Credential_t) -> *const CustomCredential_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn credential_to_x509(x: *const Credential_t) -> *const CertificateChain_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn credential_type_free(_x: u16);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn credential_type_new(raw_value: u16) -> u16;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn credential_type_raw_value(__safer_ffi_gen_self: *const u16) -> u16;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_Credential {
    #[doc = " <No documentation available>"]
    pub ptr: *mut Credential_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_Credential() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_Credential> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_Credential>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_Credential))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_Credential>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_Credential))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_Credential),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_Credential),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_Credential),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_Credential {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_Credential_t = Vec_Credential;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn credential_vec_as_slice(v: *const Vec_Credential_t) -> slice_ref_Credential_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn credential_vec_as_slice_mut(v: *mut Vec_Credential_t) -> slice_mut_Credential_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn credential_vec_free(_v: Vec_Credential_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn credential_vec_new() -> Vec_Credential_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn credential_vec_push(v: *mut Vec_Credential_t, item: *mut Credential_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn custom_credential_clone(x: *const CustomCredential_t) -> *mut CustomCredential_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn custom_credential_credential_type(
        __safer_ffi_gen_self: *const CustomCredential_t,
    ) -> u16;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn custom_credential_data(
        __safer_ffi_gen_self: *const CustomCredential_t,
    ) -> slice_ref_uint8_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn custom_credential_free(_x: *mut CustomCredential_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn custom_credential_new(
        credential_type: u16,
        data: Vec_uint8_t,
    ) -> *mut CustomCredential_t;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_CustomCredential {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const CustomCredential_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_CustomCredential() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_CustomCredential> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_CustomCredential>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_CustomCredential))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_CustomCredential>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_CustomCredential))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_CustomCredential),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_CustomCredential),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_CustomCredential {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_CustomCredential_t = slice_ref_CustomCredential;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn custom_credential_slice_get(
        items: slice_ref_CustomCredential_t,
        index: usize,
    ) -> *const CustomCredential_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_CustomCredential {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut CustomCredential_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_CustomCredential() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_CustomCredential> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_CustomCredential>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_CustomCredential))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_CustomCredential>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_CustomCredential))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_CustomCredential),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_CustomCredential),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_CustomCredential {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_CustomCredential_t = slice_mut_CustomCredential;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn custom_credential_slice_get_mut(
        items: slice_mut_CustomCredential_t,
        index: usize,
    ) -> *mut CustomCredential_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_CustomCredential {
    #[doc = " <No documentation available>"]
    pub ptr: *mut CustomCredential_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_CustomCredential() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_CustomCredential> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_CustomCredential>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_CustomCredential))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_CustomCredential>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_CustomCredential))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_CustomCredential),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_CustomCredential),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_CustomCredential),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_CustomCredential {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_CustomCredential_t = Vec_CustomCredential;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn custom_credential_vec_as_slice(
        v: *const Vec_CustomCredential_t,
    ) -> slice_ref_CustomCredential_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn custom_credential_vec_as_slice_mut(
        v: *mut Vec_CustomCredential_t,
    ) -> slice_mut_CustomCredential_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn custom_credential_vec_free(_v: Vec_CustomCredential_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn custom_credential_vec_new() -> Vec_CustomCredential_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn custom_credential_vec_push(
        v: *mut Vec_CustomCredential_t,
        item: *mut CustomCredential_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CustomProposal {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  A user defined custom proposal.\n\n  User defined proposals are passed through the protocol as an opaque value."]
pub type CustomProposal_t = CustomProposal;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn custom_proposal_clone(x: *const CustomProposal_t) -> *mut CustomProposal_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn custom_proposal_data(__safer_ffi_gen_self: *const CustomProposal_t)
        -> slice_ref_uint8_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn custom_proposal_free(_x: *mut CustomProposal_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn custom_proposal_new(proposal_type: u16, data: Vec_uint8_t) -> *mut CustomProposal_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn custom_proposal_proposal_type(__safer_ffi_gen_self: *const CustomProposal_t) -> u16;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_CustomProposal {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const CustomProposal_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_CustomProposal() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_CustomProposal> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_CustomProposal>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_CustomProposal))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_CustomProposal>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_CustomProposal))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_CustomProposal),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_CustomProposal),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_CustomProposal {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_CustomProposal_t = slice_ref_CustomProposal;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn custom_proposal_slice_get(
        items: slice_ref_CustomProposal_t,
        index: usize,
    ) -> *const CustomProposal_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_CustomProposal {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut CustomProposal_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_CustomProposal() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_CustomProposal> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_CustomProposal>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_CustomProposal))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_CustomProposal>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_CustomProposal))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_CustomProposal),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_CustomProposal),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_CustomProposal {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_CustomProposal_t = slice_mut_CustomProposal;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn custom_proposal_slice_get_mut(
        items: slice_mut_CustomProposal_t,
        index: usize,
    ) -> *mut CustomProposal_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_CustomProposal {
    #[doc = " <No documentation available>"]
    pub ptr: *mut CustomProposal_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_CustomProposal() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_CustomProposal> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_CustomProposal>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_CustomProposal))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_CustomProposal>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_CustomProposal))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_CustomProposal),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_CustomProposal),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_CustomProposal),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_CustomProposal {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_CustomProposal_t = Vec_CustomProposal;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn custom_proposal_vec_as_slice(
        v: *const Vec_CustomProposal_t,
    ) -> slice_ref_CustomProposal_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn custom_proposal_vec_as_slice_mut(
        v: *mut Vec_CustomProposal_t,
    ) -> slice_mut_CustomProposal_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn custom_proposal_vec_free(_v: Vec_CustomProposal_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn custom_proposal_vec_new() -> Vec_CustomProposal_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn custom_proposal_vec_push(v: *mut Vec_CustomProposal_t, item: *mut CustomProposal_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct DerCertificate {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  X.509 certificate in DER format."]
pub type DerCertificate_t = DerCertificate;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn der_certificate_clone(x: *const DerCertificate_t) -> *mut DerCertificate_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn der_certificate_free(_x: *mut DerCertificate_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn der_certificate_into_vec(__safer_ffi_gen_self: *mut DerCertificate_t) -> Vec_uint8_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn der_certificate_new(data: Vec_uint8_t) -> *mut DerCertificate_t;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_DerCertificate {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const DerCertificate_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_DerCertificate() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_DerCertificate> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_DerCertificate>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_DerCertificate))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_DerCertificate>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_DerCertificate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_DerCertificate),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_DerCertificate),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_DerCertificate {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_DerCertificate_t = slice_ref_DerCertificate;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn der_certificate_slice_get(
        items: slice_ref_DerCertificate_t,
        index: usize,
    ) -> *const DerCertificate_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_DerCertificate {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut DerCertificate_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_DerCertificate() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_DerCertificate> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_DerCertificate>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_DerCertificate))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_DerCertificate>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_DerCertificate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_DerCertificate),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_DerCertificate),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_DerCertificate {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_DerCertificate_t = slice_mut_DerCertificate;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn der_certificate_slice_get_mut(
        items: slice_mut_DerCertificate_t,
        index: usize,
    ) -> *mut DerCertificate_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_DerCertificate {
    #[doc = " <No documentation available>"]
    pub ptr: *mut DerCertificate_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_DerCertificate() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_DerCertificate> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_DerCertificate>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_DerCertificate))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_DerCertificate>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_DerCertificate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_DerCertificate),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_DerCertificate),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_DerCertificate),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_DerCertificate {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_DerCertificate_t = Vec_DerCertificate;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn der_certificate_vec_as_slice(
        v: *const Vec_DerCertificate_t,
    ) -> slice_ref_DerCertificate_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn der_certificate_vec_as_slice_mut(
        v: *mut Vec_DerCertificate_t,
    ) -> slice_mut_DerCertificate_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn der_certificate_vec_free(_v: Vec_DerCertificate_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn der_certificate_vec_new() -> Vec_DerCertificate_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn der_certificate_vec_push(v: *mut Vec_DerCertificate_t, item: *mut DerCertificate_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn exported_tree_byte_size(__safer_ffi_gen_self: *const ExportedTree_t) -> usize;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn exported_tree_clone(x: *const ExportedTree_t) -> *mut ExportedTree_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn exported_tree_free(_x: *mut ExportedTree_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn exported_tree_from_bytes(
        bytes: slice_ref_uint8_t,
        __safer_ffi_gen_out: *mut *mut ExportedTree_t,
    ) -> i32;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn exported_tree_into_owned(
        __safer_ffi_gen_self: *mut ExportedTree_t,
    ) -> *mut ExportedTree_t;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_ExportedTree {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const ExportedTree_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_ExportedTree() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_ExportedTree> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_ExportedTree>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_ExportedTree))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_ExportedTree>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_ExportedTree))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_ExportedTree),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_ExportedTree),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_ExportedTree {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_ExportedTree_t = slice_ref_ExportedTree;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn exported_tree_slice_get(
        items: slice_ref_ExportedTree_t,
        index: usize,
    ) -> *const ExportedTree_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_ExportedTree {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut ExportedTree_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_ExportedTree() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_ExportedTree> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_ExportedTree>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_ExportedTree))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_ExportedTree>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_ExportedTree))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_ExportedTree),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_ExportedTree),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_ExportedTree {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_ExportedTree_t = slice_mut_ExportedTree;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn exported_tree_slice_get_mut(
        items: slice_mut_ExportedTree_t,
        index: usize,
    ) -> *mut ExportedTree_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn exported_tree_to_bytes(
        __safer_ffi_gen_self: *const ExportedTree_t,
        __safer_ffi_gen_out: *mut Vec_uint8_t,
    ) -> i32;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_ExportedTree {
    #[doc = " <No documentation available>"]
    pub ptr: *mut ExportedTree_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_ExportedTree() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_ExportedTree> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_ExportedTree>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_ExportedTree))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_ExportedTree>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_ExportedTree))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ExportedTree),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ExportedTree),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ExportedTree),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_ExportedTree {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_ExportedTree_t = Vec_ExportedTree;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn exported_tree_vec_as_slice(v: *const Vec_ExportedTree_t) -> slice_ref_ExportedTree_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn exported_tree_vec_as_slice_mut(v: *mut Vec_ExportedTree_t) -> slice_mut_ExportedTree_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn exported_tree_vec_free(_v: Vec_ExportedTree_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn exported_tree_vec_new() -> Vec_ExportedTree_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn exported_tree_vec_push(v: *mut Vec_ExportedTree_t, item: *mut ExportedTree_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Extension {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  An MLS protocol [extension](https://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.html#name-extensions).\n\n  Extensions are used as customization points in various parts of the\n  MLS protocol and are inserted into an [ExtensionList](self::ExtensionList)."]
pub type Extension_t = Extension;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_clone(x: *const Extension_t) -> *mut Extension_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_extension_data(__safer_ffi_gen_self: *const Extension_t) -> slice_ref_uint8_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_extension_type(__safer_ffi_gen_self: *const Extension_t) -> u16;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_free(_x: *mut Extension_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExtensionList {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  A collection of MLS [Extensions](super::Extension).\n\n\n  # Warning\n\n  Extension lists require that each type of extension has at most one entry."]
pub type ExtensionList_t = ExtensionList;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_list_clone(x: *const ExtensionList_t) -> *mut ExtensionList_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_list_free(_x: *mut ExtensionList_t);
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_ExtensionList {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const ExtensionList_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_ExtensionList() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_ExtensionList> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_ExtensionList>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_ExtensionList))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_ExtensionList>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_ExtensionList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_ExtensionList),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_ExtensionList),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_ExtensionList {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_ExtensionList_t = slice_ref_ExtensionList;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_list_slice_get(
        items: slice_ref_ExtensionList_t,
        index: usize,
    ) -> *const ExtensionList_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_ExtensionList {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut ExtensionList_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_ExtensionList() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_ExtensionList> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_ExtensionList>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_ExtensionList))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_ExtensionList>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_ExtensionList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_ExtensionList),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_ExtensionList),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_ExtensionList {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_ExtensionList_t = slice_mut_ExtensionList;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_list_slice_get_mut(
        items: slice_mut_ExtensionList_t,
        index: usize,
    ) -> *mut ExtensionList_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_ExtensionList {
    #[doc = " <No documentation available>"]
    pub ptr: *mut ExtensionList_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_ExtensionList() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_ExtensionList> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_ExtensionList>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_ExtensionList))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_ExtensionList>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_ExtensionList))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ExtensionList),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ExtensionList),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ExtensionList),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_ExtensionList {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_ExtensionList_t = Vec_ExtensionList;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_list_vec_as_slice(v: *const Vec_ExtensionList_t) -> slice_ref_ExtensionList_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_list_vec_as_slice_mut(
        v: *mut Vec_ExtensionList_t,
    ) -> slice_mut_ExtensionList_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_list_vec_free(_v: Vec_ExtensionList_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_list_vec_new() -> Vec_ExtensionList_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_list_vec_push(v: *mut Vec_ExtensionList_t, item: *mut ExtensionList_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_new(extension_type: u16, extension_data: Vec_uint8_t) -> *mut Extension_t;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_Extension {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const Extension_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_Extension() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_Extension> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_Extension>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_Extension))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_Extension>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_Extension))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_Extension),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_Extension),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_Extension {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_Extension_t = slice_ref_Extension;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_slice_get(items: slice_ref_Extension_t, index: usize) -> *const Extension_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_Extension {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut Extension_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_Extension() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_Extension> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_Extension>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_Extension))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_Extension>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_Extension))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_Extension),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_Extension),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_Extension {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_Extension_t = slice_mut_Extension;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_slice_get_mut(items: slice_mut_Extension_t, index: usize) -> *mut Extension_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_type_free(_x: u16);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_type_is_default(__safer_ffi_gen_self: *const u16) -> bool;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_type_new(raw_value: u16) -> u16;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_type_raw_value(__safer_ffi_gen_self: *const u16) -> u16;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_Extension {
    #[doc = " <No documentation available>"]
    pub ptr: *mut Extension_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_Extension() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_Extension> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_Extension>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_Extension))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_Extension>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_Extension))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_Extension),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_Extension),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_Extension),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_Extension {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_Extension_t = Vec_Extension;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_vec_as_slice(v: *const Vec_Extension_t) -> slice_ref_Extension_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_vec_as_slice_mut(v: *mut Vec_Extension_t) -> slice_mut_Extension_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_vec_free(_v: Vec_Extension_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_vec_new() -> Vec_Extension_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn extension_vec_push(v: *mut Vec_Extension_t, item: *mut Extension_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExternalPskId {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  An external pre-shared key identifier."]
pub type ExternalPskId_t = ExternalPskId;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_psk_id_clone(x: *const ExternalPskId_t) -> *mut ExternalPskId_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_psk_id_free(_x: *mut ExternalPskId_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_psk_id_new(id_data: Vec_uint8_t) -> *mut ExternalPskId_t;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_ExternalPskId {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const ExternalPskId_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_ExternalPskId() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_ExternalPskId> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_ExternalPskId>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_ExternalPskId))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_ExternalPskId>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_ExternalPskId))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_ExternalPskId),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_ExternalPskId),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_ExternalPskId {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_ExternalPskId_t = slice_ref_ExternalPskId;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_psk_id_slice_get(
        items: slice_ref_ExternalPskId_t,
        index: usize,
    ) -> *const ExternalPskId_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_ExternalPskId {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut ExternalPskId_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_ExternalPskId() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_ExternalPskId> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_ExternalPskId>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_ExternalPskId))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_ExternalPskId>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_ExternalPskId))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_ExternalPskId),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_ExternalPskId),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_ExternalPskId {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_ExternalPskId_t = slice_mut_ExternalPskId;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_psk_id_slice_get_mut(
        items: slice_mut_ExternalPskId_t,
        index: usize,
    ) -> *mut ExternalPskId_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_ExternalPskId {
    #[doc = " <No documentation available>"]
    pub ptr: *mut ExternalPskId_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_ExternalPskId() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_ExternalPskId> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_ExternalPskId>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_ExternalPskId))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_ExternalPskId>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_ExternalPskId))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ExternalPskId),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ExternalPskId),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ExternalPskId),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_ExternalPskId {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_ExternalPskId_t = Vec_ExternalPskId;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_psk_id_vec_as_slice(v: *const Vec_ExternalPskId_t)
        -> slice_ref_ExternalPskId_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_psk_id_vec_as_slice_mut(
        v: *mut Vec_ExternalPskId_t,
    ) -> slice_mut_ExternalPskId_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_psk_id_vec_free(_v: Vec_ExternalPskId_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_psk_id_vec_new() -> Vec_ExternalPskId_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_psk_id_vec_push(v: *mut Vec_ExternalPskId_t, item: *mut ExternalPskId_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExternalPubExt {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  External public key used for [External Commits](crate::Client::commit_external).\n\n  This proposal type is optionally provided as part of a\n  [Group Info](crate::group::Group::group_info_message)."]
pub type ExternalPubExt_t = ExternalPubExt;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_pub_ext_clone(x: *const ExternalPubExt_t) -> *mut ExternalPubExt_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HpkePublicKey {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  Byte representation of an HPKE public key. For ciphersuites using elliptic curves,\n  the public key should be represented in the uncompressed format."]
pub type HpkePublicKey_t = HpkePublicKey;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_pub_ext_external_pub(
        __safer_ffi_gen_self: *const ExternalPubExt_t,
    ) -> *const HpkePublicKey_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_pub_ext_free(_x: *mut ExternalPubExt_t);
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_ExternalPubExt {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const ExternalPubExt_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_ExternalPubExt() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_ExternalPubExt> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_ExternalPubExt>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_ExternalPubExt))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_ExternalPubExt>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_ExternalPubExt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_ExternalPubExt),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_ExternalPubExt),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_ExternalPubExt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_ExternalPubExt_t = slice_ref_ExternalPubExt;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_pub_ext_slice_get(
        items: slice_ref_ExternalPubExt_t,
        index: usize,
    ) -> *const ExternalPubExt_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_ExternalPubExt {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut ExternalPubExt_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_ExternalPubExt() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_ExternalPubExt> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_ExternalPubExt>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_ExternalPubExt))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_ExternalPubExt>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_ExternalPubExt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_ExternalPubExt),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_ExternalPubExt),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_ExternalPubExt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_ExternalPubExt_t = slice_mut_ExternalPubExt;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_pub_ext_slice_get_mut(
        items: slice_mut_ExternalPubExt_t,
        index: usize,
    ) -> *mut ExternalPubExt_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_ExternalPubExt {
    #[doc = " <No documentation available>"]
    pub ptr: *mut ExternalPubExt_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_ExternalPubExt() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_ExternalPubExt> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_ExternalPubExt>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_ExternalPubExt))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_ExternalPubExt>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_ExternalPubExt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ExternalPubExt),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ExternalPubExt),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ExternalPubExt),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_ExternalPubExt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_ExternalPubExt_t = Vec_ExternalPubExt;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_pub_ext_vec_as_slice(
        v: *const Vec_ExternalPubExt_t,
    ) -> slice_ref_ExternalPubExt_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_pub_ext_vec_as_slice_mut(
        v: *mut Vec_ExternalPubExt_t,
    ) -> slice_mut_ExternalPubExt_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_pub_ext_vec_free(_v: Vec_ExternalPubExt_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_pub_ext_vec_new() -> Vec_ExternalPubExt_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_pub_ext_vec_push(v: *mut Vec_ExternalPubExt_t, item: *mut ExternalPubExt_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ExternalSendersExt {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  Enable proposals by an [ExternalClient](crate::external_client::ExternalClient)."]
pub type ExternalSendersExt_t = ExternalSendersExt;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SigningIdentity {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  MLS group member identity represented as a combination of a\n  public [`SignaturePublicKey`] and [`Credential`]."]
pub type SigningIdentity_t = SigningIdentity;
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_SigningIdentity {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const SigningIdentity_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_SigningIdentity() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_SigningIdentity> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_SigningIdentity>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_SigningIdentity))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_SigningIdentity>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_SigningIdentity))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_SigningIdentity),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_SigningIdentity),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_SigningIdentity {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_SigningIdentity_t = slice_ref_SigningIdentity;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_senders_ext_allowed_senders(
        __safer_ffi_gen_self: *const ExternalSendersExt_t,
    ) -> slice_ref_SigningIdentity_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_senders_ext_clone(x: *const ExternalSendersExt_t) -> *mut ExternalSendersExt_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_senders_ext_free(_x: *mut ExternalSendersExt_t);
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_SigningIdentity {
    #[doc = " <No documentation available>"]
    pub ptr: *mut SigningIdentity_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_SigningIdentity() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_SigningIdentity> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_SigningIdentity>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_SigningIdentity))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_SigningIdentity>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_SigningIdentity))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_SigningIdentity),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_SigningIdentity),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_SigningIdentity),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_SigningIdentity {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_SigningIdentity_t = Vec_SigningIdentity;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_senders_ext_new(
        allowed_senders: Vec_SigningIdentity_t,
    ) -> *mut ExternalSendersExt_t;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_ExternalSendersExt {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const ExternalSendersExt_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_ExternalSendersExt() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_ExternalSendersExt> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_ExternalSendersExt>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_ExternalSendersExt))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_ExternalSendersExt>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_ExternalSendersExt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_ExternalSendersExt),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_ExternalSendersExt),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_ExternalSendersExt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_ExternalSendersExt_t = slice_ref_ExternalSendersExt;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_senders_ext_slice_get(
        items: slice_ref_ExternalSendersExt_t,
        index: usize,
    ) -> *const ExternalSendersExt_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_ExternalSendersExt {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut ExternalSendersExt_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_ExternalSendersExt() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_ExternalSendersExt> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_ExternalSendersExt>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_ExternalSendersExt))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_ExternalSendersExt>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_ExternalSendersExt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_ExternalSendersExt),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_ExternalSendersExt),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_ExternalSendersExt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_ExternalSendersExt_t = slice_mut_ExternalSendersExt;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_senders_ext_slice_get_mut(
        items: slice_mut_ExternalSendersExt_t,
        index: usize,
    ) -> *mut ExternalSendersExt_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_ExternalSendersExt {
    #[doc = " <No documentation available>"]
    pub ptr: *mut ExternalSendersExt_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_ExternalSendersExt() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_ExternalSendersExt> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_ExternalSendersExt>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_ExternalSendersExt))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_ExternalSendersExt>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_ExternalSendersExt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ExternalSendersExt),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ExternalSendersExt),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ExternalSendersExt),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_ExternalSendersExt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_ExternalSendersExt_t = Vec_ExternalSendersExt;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_senders_ext_vec_as_slice(
        v: *const Vec_ExternalSendersExt_t,
    ) -> slice_ref_ExternalSendersExt_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_senders_ext_vec_as_slice_mut(
        v: *mut Vec_ExternalSendersExt_t,
    ) -> slice_mut_ExternalSendersExt_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_senders_ext_vec_free(_v: Vec_ExternalSendersExt_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_senders_ext_vec_new() -> Vec_ExternalSendersExt_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn external_senders_ext_vec_push(
        v: *mut Vec_ExternalSendersExt_t,
        item: *mut ExternalSendersExt_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupConfig {
    _unused: [u8; 0],
}
#[doc = " <No documentation available>"]
pub type GroupConfig_t = GroupConfig;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_config_free(_x: *mut GroupConfig_t);
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_GroupConfig {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const GroupConfig_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_GroupConfig() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_GroupConfig> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_GroupConfig>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_GroupConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_GroupConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_GroupConfig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_GroupConfig),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_GroupConfig),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_GroupConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_GroupConfig_t = slice_ref_GroupConfig;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_config_slice_get(
        items: slice_ref_GroupConfig_t,
        index: usize,
    ) -> *const GroupConfig_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_GroupConfig {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut GroupConfig_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_GroupConfig() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_GroupConfig> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_GroupConfig>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_GroupConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_GroupConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_GroupConfig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_GroupConfig),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_GroupConfig),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_GroupConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_GroupConfig_t = slice_mut_GroupConfig;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_config_slice_get_mut(
        items: slice_mut_GroupConfig_t,
        index: usize,
    ) -> *mut GroupConfig_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_GroupConfig {
    #[doc = " <No documentation available>"]
    pub ptr: *mut GroupConfig_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_GroupConfig() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_GroupConfig> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_GroupConfig>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_GroupConfig))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_GroupConfig>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_GroupConfig))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_GroupConfig),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_GroupConfig),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_GroupConfig),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_GroupConfig {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_GroupConfig_t = Vec_GroupConfig;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_config_vec_as_slice(v: *const Vec_GroupConfig_t) -> slice_ref_GroupConfig_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_config_vec_as_slice_mut(v: *mut Vec_GroupConfig_t) -> slice_mut_GroupConfig_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_config_vec_free(_v: Vec_GroupConfig_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_config_vec_new() -> Vec_GroupConfig_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_config_vec_push(v: *mut Vec_GroupConfig_t, item: *mut GroupConfig_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupContext {
    _unused: [u8; 0],
}
#[doc = " <No documentation available>"]
pub type GroupContext_t = GroupContext;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_context_cipher_suite(__safer_ffi_gen_self: *const GroupContext_t) -> u16;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_context_clone(x: *const GroupContext_t) -> *mut GroupContext_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_context_epoch(__safer_ffi_gen_self: *const GroupContext_t) -> u64;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_context_extensions(
        __safer_ffi_gen_self: *const GroupContext_t,
    ) -> *const ExtensionList_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupContextExtensions {
    _unused: [u8; 0],
}
#[doc = " <No documentation available>"]
pub type GroupContextExtensions_t = GroupContextExtensions;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_context_extensions_free(_x: *mut GroupContextExtensions_t);
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_GroupContextExtensions {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const GroupContextExtensions_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_GroupContextExtensions() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_GroupContextExtensions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_GroupContextExtensions>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_GroupContextExtensions))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_GroupContextExtensions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(slice_ref_GroupContextExtensions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_GroupContextExtensions),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_GroupContextExtensions),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_GroupContextExtensions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_GroupContextExtensions_t = slice_ref_GroupContextExtensions;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_context_extensions_slice_get(
        items: slice_ref_GroupContextExtensions_t,
        index: usize,
    ) -> *const GroupContextExtensions_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_GroupContextExtensions {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut GroupContextExtensions_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_GroupContextExtensions() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_GroupContextExtensions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_GroupContextExtensions>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_GroupContextExtensions))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_GroupContextExtensions>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(slice_mut_GroupContextExtensions)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_GroupContextExtensions),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_GroupContextExtensions),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_GroupContextExtensions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_GroupContextExtensions_t = slice_mut_GroupContextExtensions;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_context_extensions_slice_get_mut(
        items: slice_mut_GroupContextExtensions_t,
        index: usize,
    ) -> *mut GroupContextExtensions_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_GroupContextExtensions {
    #[doc = " <No documentation available>"]
    pub ptr: *mut GroupContextExtensions_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_GroupContextExtensions() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_GroupContextExtensions> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_GroupContextExtensions>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_GroupContextExtensions))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_GroupContextExtensions>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_GroupContextExtensions))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_GroupContextExtensions),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_GroupContextExtensions),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_GroupContextExtensions),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_GroupContextExtensions {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_GroupContextExtensions_t = Vec_GroupContextExtensions;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_context_extensions_vec_as_slice(
        v: *const Vec_GroupContextExtensions_t,
    ) -> slice_ref_GroupContextExtensions_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_context_extensions_vec_as_slice_mut(
        v: *mut Vec_GroupContextExtensions_t,
    ) -> slice_mut_GroupContextExtensions_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_context_extensions_vec_free(_v: Vec_GroupContextExtensions_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_context_extensions_vec_new() -> Vec_GroupContextExtensions_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_context_extensions_vec_push(
        v: *mut Vec_GroupContextExtensions_t,
        item: *mut GroupContextExtensions_t,
    );
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_context_free(_x: *mut GroupContext_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_context_group_id(__safer_ffi_gen_self: *const GroupContext_t)
        -> slice_ref_uint8_t;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_GroupContext {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const GroupContext_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_GroupContext() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_GroupContext> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_GroupContext>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_GroupContext))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_GroupContext>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_GroupContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_GroupContext),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_GroupContext),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_GroupContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_GroupContext_t = slice_ref_GroupContext;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_context_slice_get(
        items: slice_ref_GroupContext_t,
        index: usize,
    ) -> *const GroupContext_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_GroupContext {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut GroupContext_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_GroupContext() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_GroupContext> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_GroupContext>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_GroupContext))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_GroupContext>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_GroupContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_GroupContext),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_GroupContext),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_GroupContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_GroupContext_t = slice_mut_GroupContext;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_context_slice_get_mut(
        items: slice_mut_GroupContext_t,
        index: usize,
    ) -> *mut GroupContext_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_GroupContext {
    #[doc = " <No documentation available>"]
    pub ptr: *mut GroupContext_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_GroupContext() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_GroupContext> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_GroupContext>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_GroupContext))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_GroupContext>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_GroupContext))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_GroupContext),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_GroupContext),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_GroupContext),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_GroupContext {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_GroupContext_t = Vec_GroupContext;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_context_vec_as_slice(v: *const Vec_GroupContext_t) -> slice_ref_GroupContext_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_context_vec_as_slice_mut(v: *mut Vec_GroupContext_t) -> slice_mut_GroupContext_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_context_vec_free(_v: Vec_GroupContext_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_context_vec_new() -> Vec_GroupContext_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_context_vec_push(v: *mut Vec_GroupContext_t, item: *mut GroupContext_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_context_version(__safer_ffi_gen_self: *const GroupContext_t) -> u16;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct GroupInfo {
    _unused: [u8; 0],
}
#[doc = " <No documentation available>"]
pub type GroupInfo_t = GroupInfo;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_info_clone(x: *const GroupInfo_t) -> *mut GroupInfo_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_info_extensions(
        __safer_ffi_gen_self: *const GroupInfo_t,
    ) -> *const ExtensionList_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_info_free(_x: *mut GroupInfo_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_info_group_context(
        __safer_ffi_gen_self: *const GroupInfo_t,
    ) -> *const GroupContext_t;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_GroupInfo {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const GroupInfo_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_GroupInfo() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_GroupInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_GroupInfo>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_GroupInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_GroupInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_GroupInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_GroupInfo),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_GroupInfo),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_GroupInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_GroupInfo_t = slice_ref_GroupInfo;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_info_slice_get(items: slice_ref_GroupInfo_t, index: usize) -> *const GroupInfo_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_GroupInfo {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut GroupInfo_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_GroupInfo() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_GroupInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_GroupInfo>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_GroupInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_GroupInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_GroupInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_GroupInfo),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_GroupInfo),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_GroupInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_GroupInfo_t = slice_mut_GroupInfo;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_info_slice_get_mut(items: slice_mut_GroupInfo_t, index: usize)
        -> *mut GroupInfo_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_GroupInfo {
    #[doc = " <No documentation available>"]
    pub ptr: *mut GroupInfo_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_GroupInfo() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_GroupInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_GroupInfo>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_GroupInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_GroupInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_GroupInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_GroupInfo),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_GroupInfo),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_GroupInfo),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_GroupInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_GroupInfo_t = Vec_GroupInfo;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_info_vec_as_slice(v: *const Vec_GroupInfo_t) -> slice_ref_GroupInfo_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_info_vec_as_slice_mut(v: *mut Vec_GroupInfo_t) -> slice_mut_GroupInfo_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_info_vec_free(_v: Vec_GroupInfo_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_info_vec_new() -> Vec_GroupInfo_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn group_info_vec_push(v: *mut Vec_GroupInfo_t, item: *mut GroupInfo_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn hpke_public_key_clone(x: *const HpkePublicKey_t) -> *mut HpkePublicKey_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn hpke_public_key_free(_x: *mut HpkePublicKey_t);
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_HpkePublicKey {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const HpkePublicKey_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_HpkePublicKey() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_HpkePublicKey> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_HpkePublicKey>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_HpkePublicKey))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_HpkePublicKey>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_HpkePublicKey))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_HpkePublicKey),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_HpkePublicKey),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_HpkePublicKey {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_HpkePublicKey_t = slice_ref_HpkePublicKey;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn hpke_public_key_slice_get(
        items: slice_ref_HpkePublicKey_t,
        index: usize,
    ) -> *const HpkePublicKey_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_HpkePublicKey {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut HpkePublicKey_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_HpkePublicKey() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_HpkePublicKey> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_HpkePublicKey>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_HpkePublicKey))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_HpkePublicKey>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_HpkePublicKey))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_HpkePublicKey),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_HpkePublicKey),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_HpkePublicKey {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_HpkePublicKey_t = slice_mut_HpkePublicKey;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn hpke_public_key_slice_get_mut(
        items: slice_mut_HpkePublicKey_t,
        index: usize,
    ) -> *mut HpkePublicKey_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_HpkePublicKey {
    #[doc = " <No documentation available>"]
    pub ptr: *mut HpkePublicKey_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_HpkePublicKey() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_HpkePublicKey> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_HpkePublicKey>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_HpkePublicKey))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_HpkePublicKey>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_HpkePublicKey))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_HpkePublicKey),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_HpkePublicKey),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_HpkePublicKey),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_HpkePublicKey {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_HpkePublicKey_t = Vec_HpkePublicKey;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn hpke_public_key_vec_as_slice(v: *const Vec_HpkePublicKey_t)
        -> slice_ref_HpkePublicKey_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn hpke_public_key_vec_as_slice_mut(
        v: *mut Vec_HpkePublicKey_t,
    ) -> slice_mut_HpkePublicKey_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn hpke_public_key_vec_free(_v: Vec_HpkePublicKey_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn hpke_public_key_vec_new() -> Vec_HpkePublicKey_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn hpke_public_key_vec_push(v: *mut Vec_HpkePublicKey_t, item: *mut HpkePublicKey_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct HpkeSecretKey {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  Byte representation of an HPKE secret key."]
pub type HpkeSecretKey_t = HpkeSecretKey;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn hpke_secret_key_clone(x: *const HpkeSecretKey_t) -> *mut HpkeSecretKey_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn hpke_secret_key_free(_x: *mut HpkeSecretKey_t);
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_HpkeSecretKey {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const HpkeSecretKey_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_HpkeSecretKey() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_HpkeSecretKey> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_HpkeSecretKey>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_HpkeSecretKey))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_HpkeSecretKey>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_HpkeSecretKey))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_HpkeSecretKey),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_HpkeSecretKey),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_HpkeSecretKey {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_HpkeSecretKey_t = slice_ref_HpkeSecretKey;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn hpke_secret_key_slice_get(
        items: slice_ref_HpkeSecretKey_t,
        index: usize,
    ) -> *const HpkeSecretKey_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_HpkeSecretKey {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut HpkeSecretKey_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_HpkeSecretKey() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_HpkeSecretKey> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_HpkeSecretKey>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_HpkeSecretKey))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_HpkeSecretKey>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_HpkeSecretKey))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_HpkeSecretKey),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_HpkeSecretKey),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_HpkeSecretKey {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_HpkeSecretKey_t = slice_mut_HpkeSecretKey;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn hpke_secret_key_slice_get_mut(
        items: slice_mut_HpkeSecretKey_t,
        index: usize,
    ) -> *mut HpkeSecretKey_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_HpkeSecretKey {
    #[doc = " <No documentation available>"]
    pub ptr: *mut HpkeSecretKey_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_HpkeSecretKey() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_HpkeSecretKey> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_HpkeSecretKey>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_HpkeSecretKey))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_HpkeSecretKey>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_HpkeSecretKey))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_HpkeSecretKey),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_HpkeSecretKey),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_HpkeSecretKey),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_HpkeSecretKey {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_HpkeSecretKey_t = Vec_HpkeSecretKey;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn hpke_secret_key_vec_as_slice(v: *const Vec_HpkeSecretKey_t)
        -> slice_ref_HpkeSecretKey_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn hpke_secret_key_vec_as_slice_mut(
        v: *mut Vec_HpkeSecretKey_t,
    ) -> slice_mut_HpkeSecretKey_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn hpke_secret_key_vec_free(_v: Vec_HpkeSecretKey_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn hpke_secret_key_vec_new() -> Vec_HpkeSecretKey_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn hpke_secret_key_vec_push(v: *mut Vec_HpkeSecretKey_t, item: *mut HpkeSecretKey_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KeyPackage {
    _unused: [u8; 0],
}
#[doc = " <No documentation available>"]
pub type KeyPackage_t = KeyPackage;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn key_package_cipher_suite(__safer_ffi_gen_self: *const KeyPackage_t) -> u16;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn key_package_clone(x: *const KeyPackage_t) -> *mut KeyPackage_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn key_package_expiration(
        __safer_ffi_gen_self: *const KeyPackage_t,
        __safer_ffi_gen_out: *mut u64,
    ) -> i32;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn key_package_free(_x: *mut KeyPackage_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KeyPackageRef {
    _unused: [u8; 0],
}
#[doc = " <No documentation available>"]
pub type KeyPackageRef_t = KeyPackageRef;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn key_package_ref_clone(x: *const KeyPackageRef_t) -> *mut KeyPackageRef_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn key_package_ref_free(_x: *mut KeyPackageRef_t);
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_KeyPackageRef {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const KeyPackageRef_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_KeyPackageRef() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_KeyPackageRef> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_KeyPackageRef>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_KeyPackageRef))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_KeyPackageRef>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_KeyPackageRef))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_KeyPackageRef),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_KeyPackageRef),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_KeyPackageRef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_KeyPackageRef_t = slice_ref_KeyPackageRef;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn key_package_ref_slice_get(
        items: slice_ref_KeyPackageRef_t,
        index: usize,
    ) -> *const KeyPackageRef_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_KeyPackageRef {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut KeyPackageRef_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_KeyPackageRef() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_KeyPackageRef> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_KeyPackageRef>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_KeyPackageRef))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_KeyPackageRef>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_KeyPackageRef))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_KeyPackageRef),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_KeyPackageRef),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_KeyPackageRef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_KeyPackageRef_t = slice_mut_KeyPackageRef;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn key_package_ref_slice_get_mut(
        items: slice_mut_KeyPackageRef_t,
        index: usize,
    ) -> *mut KeyPackageRef_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_KeyPackageRef {
    #[doc = " <No documentation available>"]
    pub ptr: *mut KeyPackageRef_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_KeyPackageRef() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_KeyPackageRef> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_KeyPackageRef>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_KeyPackageRef))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_KeyPackageRef>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_KeyPackageRef))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_KeyPackageRef),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_KeyPackageRef),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_KeyPackageRef),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_KeyPackageRef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_KeyPackageRef_t = Vec_KeyPackageRef;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn key_package_ref_vec_as_slice(v: *const Vec_KeyPackageRef_t)
        -> slice_ref_KeyPackageRef_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn key_package_ref_vec_as_slice_mut(
        v: *mut Vec_KeyPackageRef_t,
    ) -> slice_mut_KeyPackageRef_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn key_package_ref_vec_free(_v: Vec_KeyPackageRef_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn key_package_ref_vec_new() -> Vec_KeyPackageRef_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn key_package_ref_vec_push(v: *mut Vec_KeyPackageRef_t, item: *mut KeyPackageRef_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn key_package_signing_identity(
        __safer_ffi_gen_self: *const KeyPackage_t,
    ) -> *const SigningIdentity_t;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_KeyPackage {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const KeyPackage_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_KeyPackage() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_KeyPackage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_KeyPackage>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_KeyPackage))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_KeyPackage>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_KeyPackage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_KeyPackage),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_KeyPackage),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_KeyPackage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_KeyPackage_t = slice_ref_KeyPackage;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn key_package_slice_get(
        items: slice_ref_KeyPackage_t,
        index: usize,
    ) -> *const KeyPackage_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_KeyPackage {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut KeyPackage_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_KeyPackage() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_KeyPackage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_KeyPackage>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_KeyPackage))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_KeyPackage>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_KeyPackage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_KeyPackage),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_KeyPackage),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_KeyPackage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_KeyPackage_t = slice_mut_KeyPackage;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn key_package_slice_get_mut(
        items: slice_mut_KeyPackage_t,
        index: usize,
    ) -> *mut KeyPackage_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_KeyPackage {
    #[doc = " <No documentation available>"]
    pub ptr: *mut KeyPackage_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_KeyPackage() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_KeyPackage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_KeyPackage>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_KeyPackage))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_KeyPackage>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_KeyPackage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_KeyPackage),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_KeyPackage),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_KeyPackage),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_KeyPackage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_KeyPackage_t = Vec_KeyPackage;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn key_package_vec_as_slice(v: *const Vec_KeyPackage_t) -> slice_ref_KeyPackage_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn key_package_vec_as_slice_mut(v: *mut Vec_KeyPackage_t) -> slice_mut_KeyPackage_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn key_package_vec_free(_v: Vec_KeyPackage_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn key_package_vec_new() -> Vec_KeyPackage_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn key_package_vec_push(v: *mut Vec_KeyPackage_t, item: *mut KeyPackage_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn key_package_version(__safer_ffi_gen_self: *const KeyPackage_t) -> u16;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn last_error() -> Vec_uint8_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LiteClient {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  An MLS client used to create key packages and manage groups.\n\n  See [`mls_rs::Client`] for details."]
pub type LiteClient_t = LiteClient;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LiteGroup {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  An MLS end-to-end encrypted group.\n\n  The group is used to send and process incoming messages and to\n  add/remove users.\n\n  See [`mls_rs::Group`] for details."]
pub type LiteGroup_t = LiteGroup;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_client_create_group(
        __safer_ffi_gen_self: *const LiteClient_t,
        group_id: Vec_uint8_t,
        __safer_ffi_gen_out: *mut *mut LiteGroup_t,
    ) -> i32;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_client_free(_x: *mut LiteClient_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LiteMessage {
    _unused: [u8; 0],
}
#[doc = " <No documentation available>"]
pub type LiteMessage_t = LiteMessage;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_client_generate_key_package_message(
        __safer_ffi_gen_self: *const LiteClient_t,
        __safer_ffi_gen_out: *mut *mut LiteMessage_t,
    ) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SignatureKeypair {
    _unused: [u8; 0],
}
#[doc = " <No documentation available>"]
pub type SignatureKeypair_t = SignatureKeypair;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_client_generate_signature_keypair(
        cipher_suite: u16,
        __safer_ffi_gen_out: *mut *mut SignatureKeypair_t,
    ) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct LiteNewMemberInfo {
    _unused: [u8; 0],
}
#[doc = " <No documentation available>"]
pub type LiteNewMemberInfo_t = LiteNewMemberInfo;
#[doc = " \\brief\n  Simplified for lighter documentation, but the actual impls\n  range from `Tuple1` up to `Tuple6`."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Tuple2_LiteGroup_ptr_LiteNewMemberInfo_ptr {
    #[doc = " <No documentation available>"]
    pub _0: *mut LiteGroup_t,
    #[doc = " <No documentation available>"]
    pub _1: *mut LiteNewMemberInfo_t,
}
#[test]
fn bindgen_test_layout_Tuple2_LiteGroup_ptr_LiteNewMemberInfo_ptr() {
    const UNINIT: ::std::mem::MaybeUninit<Tuple2_LiteGroup_ptr_LiteNewMemberInfo_ptr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Tuple2_LiteGroup_ptr_LiteNewMemberInfo_ptr>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(Tuple2_LiteGroup_ptr_LiteNewMemberInfo_ptr)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<Tuple2_LiteGroup_ptr_LiteNewMemberInfo_ptr>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(Tuple2_LiteGroup_ptr_LiteNewMemberInfo_ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._0) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Tuple2_LiteGroup_ptr_LiteNewMemberInfo_ptr),
            "::",
            stringify!(_0)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._1) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Tuple2_LiteGroup_ptr_LiteNewMemberInfo_ptr),
            "::",
            stringify!(_1)
        )
    );
}
impl Default for Tuple2_LiteGroup_ptr_LiteNewMemberInfo_ptr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Simplified for lighter documentation, but the actual impls\n  range from `Tuple1` up to `Tuple6`."]
pub type Tuple2_LiteGroup_ptr_LiteNewMemberInfo_ptr_t = Tuple2_LiteGroup_ptr_LiteNewMemberInfo_ptr;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_client_join_group(
        __safer_ffi_gen_self: *const LiteClient_t,
        welcome_message: *mut MlsMessage_t,
        __safer_ffi_gen_out: *mut Tuple2_LiteGroup_ptr_LiteNewMemberInfo_ptr_t,
    ) -> i32;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_client_new(
        id: Vec_uint8_t,
        signature_keypair: *mut SignatureKeypair_t,
        cipher_suite: u16,
    ) -> *mut LiteClient_t;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_LiteClient {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const LiteClient_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_LiteClient() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_LiteClient> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_LiteClient>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_LiteClient))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_LiteClient>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_LiteClient))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_LiteClient),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_LiteClient),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_LiteClient {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_LiteClient_t = slice_ref_LiteClient;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_client_slice_get(
        items: slice_ref_LiteClient_t,
        index: usize,
    ) -> *const LiteClient_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_LiteClient {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut LiteClient_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_LiteClient() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_LiteClient> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_LiteClient>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_LiteClient))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_LiteClient>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_LiteClient))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_LiteClient),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_LiteClient),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_LiteClient {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_LiteClient_t = slice_mut_LiteClient;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_client_slice_get_mut(
        items: slice_mut_LiteClient_t,
        index: usize,
    ) -> *mut LiteClient_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_LiteClient {
    #[doc = " <No documentation available>"]
    pub ptr: *mut LiteClient_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_LiteClient() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_LiteClient> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_LiteClient>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_LiteClient))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_LiteClient>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_LiteClient))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_LiteClient),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_LiteClient),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_LiteClient),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_LiteClient {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_LiteClient_t = Vec_LiteClient;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_client_vec_as_slice(v: *const Vec_LiteClient_t) -> slice_ref_LiteClient_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_client_vec_as_slice_mut(v: *mut Vec_LiteClient_t) -> slice_mut_LiteClient_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_client_vec_free(_v: Vec_LiteClient_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_client_vec_new() -> Vec_LiteClient_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_client_vec_push(v: *mut Vec_LiteClient_t, item: *mut LiteClient_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_group_add_member(
        __safer_ffi_gen_self: *mut LiteGroup_t,
        member: *mut LiteMessage_t,
        __safer_ffi_gen_out: *mut *mut CommitOutput_t,
    ) -> i32;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_group_apply_pending_commit(__safer_ffi_gen_self: *mut LiteGroup_t) -> i32;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_group_commit(
        __safer_ffi_gen_self: *mut LiteGroup_t,
        __safer_ffi_gen_out: *mut *mut CommitOutput_t,
    ) -> i32;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_group_free(_x: *mut LiteGroup_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_group_propose_add_member(
        __safer_ffi_gen_self: *mut LiteGroup_t,
        member: *mut LiteMessage_t,
        __safer_ffi_gen_out: *mut *mut LiteMessage_t,
    ) -> i32;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_group_propose_remove_member(
        __safer_ffi_gen_self: *mut LiteGroup_t,
        member: *mut LiteMessage_t,
        __safer_ffi_gen_out: *mut *mut LiteMessage_t,
    ) -> i32;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_group_remove_member(
        __safer_ffi_gen_self: *mut LiteGroup_t,
        member: *mut LiteMessage_t,
        __safer_ffi_gen_out: *mut *mut CommitOutput_t,
    ) -> i32;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Roster {
    _unused: [u8; 0],
}
#[doc = " <No documentation available>"]
pub type Roster_t = Roster;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_group_roster(__safer_ffi_gen_self: *const LiteGroup_t) -> *mut Roster_t;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_LiteGroup {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const LiteGroup_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_LiteGroup() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_LiteGroup> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_LiteGroup>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_LiteGroup))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_LiteGroup>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_LiteGroup))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_LiteGroup),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_LiteGroup),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_LiteGroup {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_LiteGroup_t = slice_ref_LiteGroup;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_group_slice_get(items: slice_ref_LiteGroup_t, index: usize) -> *const LiteGroup_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_LiteGroup {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut LiteGroup_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_LiteGroup() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_LiteGroup> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_LiteGroup>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_LiteGroup))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_LiteGroup>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_LiteGroup))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_LiteGroup),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_LiteGroup),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_LiteGroup {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_LiteGroup_t = slice_mut_LiteGroup;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_group_slice_get_mut(items: slice_mut_LiteGroup_t, index: usize)
        -> *mut LiteGroup_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_LiteGroup {
    #[doc = " <No documentation available>"]
    pub ptr: *mut LiteGroup_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_LiteGroup() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_LiteGroup> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_LiteGroup>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_LiteGroup))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_LiteGroup>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_LiteGroup))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_LiteGroup),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_LiteGroup),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_LiteGroup),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_LiteGroup {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_LiteGroup_t = Vec_LiteGroup;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_group_vec_as_slice(v: *const Vec_LiteGroup_t) -> slice_ref_LiteGroup_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_group_vec_as_slice_mut(v: *mut Vec_LiteGroup_t) -> slice_mut_LiteGroup_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_group_vec_free(_v: Vec_LiteGroup_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_group_vec_new() -> Vec_LiteGroup_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_group_vec_push(v: *mut Vec_LiteGroup_t, item: *mut LiteGroup_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_message_free(_x: *mut LiteMessage_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_message_into_key_package(
        __safer_ffi_gen_self: *mut LiteMessage_t,
    ) -> *mut KeyPackage_t;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_LiteMessage {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const LiteMessage_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_LiteMessage() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_LiteMessage> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_LiteMessage>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_LiteMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_LiteMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_LiteMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_LiteMessage),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_LiteMessage),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_LiteMessage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_LiteMessage_t = slice_ref_LiteMessage;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_message_slice_get(
        items: slice_ref_LiteMessage_t,
        index: usize,
    ) -> *const LiteMessage_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_LiteMessage {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut LiteMessage_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_LiteMessage() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_LiteMessage> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_LiteMessage>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_LiteMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_LiteMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_LiteMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_LiteMessage),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_LiteMessage),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_LiteMessage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_LiteMessage_t = slice_mut_LiteMessage;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_message_slice_get_mut(
        items: slice_mut_LiteMessage_t,
        index: usize,
    ) -> *mut LiteMessage_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_LiteMessage {
    #[doc = " <No documentation available>"]
    pub ptr: *mut LiteMessage_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_LiteMessage() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_LiteMessage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_LiteMessage>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_LiteMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_LiteMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_LiteMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_LiteMessage),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_LiteMessage),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_LiteMessage),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_LiteMessage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_LiteMessage_t = Vec_LiteMessage;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_message_vec_as_slice(v: *const Vec_LiteMessage_t) -> slice_ref_LiteMessage_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_message_vec_as_slice_mut(v: *mut Vec_LiteMessage_t) -> slice_mut_LiteMessage_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_message_vec_free(_v: Vec_LiteMessage_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_message_vec_new() -> Vec_LiteMessage_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_message_vec_push(v: *mut Vec_LiteMessage_t, item: *mut LiteMessage_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_new_member_info_free(_x: *mut LiteNewMemberInfo_t);
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_LiteNewMemberInfo {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const LiteNewMemberInfo_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_LiteNewMemberInfo() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_LiteNewMemberInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_LiteNewMemberInfo>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_LiteNewMemberInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_LiteNewMemberInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_LiteNewMemberInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_LiteNewMemberInfo),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_LiteNewMemberInfo),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_LiteNewMemberInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_LiteNewMemberInfo_t = slice_ref_LiteNewMemberInfo;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_new_member_info_slice_get(
        items: slice_ref_LiteNewMemberInfo_t,
        index: usize,
    ) -> *const LiteNewMemberInfo_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_LiteNewMemberInfo {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut LiteNewMemberInfo_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_LiteNewMemberInfo() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_LiteNewMemberInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_LiteNewMemberInfo>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_LiteNewMemberInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_LiteNewMemberInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_LiteNewMemberInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_LiteNewMemberInfo),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_LiteNewMemberInfo),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_LiteNewMemberInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_LiteNewMemberInfo_t = slice_mut_LiteNewMemberInfo;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_new_member_info_slice_get_mut(
        items: slice_mut_LiteNewMemberInfo_t,
        index: usize,
    ) -> *mut LiteNewMemberInfo_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_LiteNewMemberInfo {
    #[doc = " <No documentation available>"]
    pub ptr: *mut LiteNewMemberInfo_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_LiteNewMemberInfo() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_LiteNewMemberInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_LiteNewMemberInfo>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_LiteNewMemberInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_LiteNewMemberInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_LiteNewMemberInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_LiteNewMemberInfo),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_LiteNewMemberInfo),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_LiteNewMemberInfo),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_LiteNewMemberInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_LiteNewMemberInfo_t = Vec_LiteNewMemberInfo;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_new_member_info_vec_as_slice(
        v: *const Vec_LiteNewMemberInfo_t,
    ) -> slice_ref_LiteNewMemberInfo_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_new_member_info_vec_as_slice_mut(
        v: *mut Vec_LiteNewMemberInfo_t,
    ) -> slice_mut_LiteNewMemberInfo_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_new_member_info_vec_free(_v: Vec_LiteNewMemberInfo_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_new_member_info_vec_new() -> Vec_LiteNewMemberInfo_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn lite_new_member_info_vec_push(
        v: *mut Vec_LiteNewMemberInfo_t,
        item: *mut LiteNewMemberInfo_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Member {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  A member of a MLS group."]
pub type Member_t = Member;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_capabilities(__safer_ffi_gen_self: *const Member_t) -> *const Capabilities_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_clone(x: *const Member_t) -> *mut Member_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_extensions(__safer_ffi_gen_self: *const Member_t) -> *const ExtensionList_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_free(_x: *mut Member_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_index(__safer_ffi_gen_self: *const Member_t) -> u32;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_new(
        index: u32,
        signing_identity: *mut SigningIdentity_t,
        capabilities: *mut Capabilities_t,
        extensions: *mut ExtensionList_t,
    ) -> *mut Member_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_signing_identity(
        __safer_ffi_gen_self: *const Member_t,
    ) -> *const SigningIdentity_t;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_Member {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const Member_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_Member() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_Member> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_Member>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_Member))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_Member>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_Member))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_Member),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_Member),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_Member {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_Member_t = slice_ref_Member;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_slice_get(items: slice_ref_Member_t, index: usize) -> *const Member_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_Member {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut Member_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_Member() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_Member> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_Member>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_Member))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_Member>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_Member))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_Member),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_Member),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_Member {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_Member_t = slice_mut_Member;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_slice_get_mut(items: slice_mut_Member_t, index: usize) -> *mut Member_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MemberUpdate {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  Update of a member due to a commit."]
pub type MemberUpdate_t = MemberUpdate;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_update_after_update(
        __safer_ffi_gen_self: *const MemberUpdate_t,
    ) -> *const Member_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_update_before_update(
        __safer_ffi_gen_self: *const MemberUpdate_t,
    ) -> *const Member_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_update_clone(x: *const MemberUpdate_t) -> *mut MemberUpdate_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_update_free(_x: *mut MemberUpdate_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_update_index(__safer_ffi_gen_self: *const MemberUpdate_t) -> u32;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_update_new(prior: *mut Member_t, new: *mut Member_t) -> *mut MemberUpdate_t;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_MemberUpdate {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const MemberUpdate_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_MemberUpdate() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_MemberUpdate> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_MemberUpdate>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_MemberUpdate))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_MemberUpdate>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_MemberUpdate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_MemberUpdate),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_MemberUpdate),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_MemberUpdate {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_MemberUpdate_t = slice_ref_MemberUpdate;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_update_slice_get(
        items: slice_ref_MemberUpdate_t,
        index: usize,
    ) -> *const MemberUpdate_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_MemberUpdate {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut MemberUpdate_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_MemberUpdate() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_MemberUpdate> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_MemberUpdate>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_MemberUpdate))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_MemberUpdate>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_MemberUpdate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_MemberUpdate),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_MemberUpdate),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_MemberUpdate {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_MemberUpdate_t = slice_mut_MemberUpdate;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_update_slice_get_mut(
        items: slice_mut_MemberUpdate_t,
        index: usize,
    ) -> *mut MemberUpdate_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_MemberUpdate {
    #[doc = " <No documentation available>"]
    pub ptr: *mut MemberUpdate_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_MemberUpdate() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_MemberUpdate> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_MemberUpdate>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_MemberUpdate))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_MemberUpdate>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_MemberUpdate))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_MemberUpdate),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_MemberUpdate),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_MemberUpdate),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_MemberUpdate {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_MemberUpdate_t = Vec_MemberUpdate;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_update_vec_as_slice(v: *const Vec_MemberUpdate_t) -> slice_ref_MemberUpdate_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_update_vec_as_slice_mut(v: *mut Vec_MemberUpdate_t) -> slice_mut_MemberUpdate_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_update_vec_free(_v: Vec_MemberUpdate_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_update_vec_new() -> Vec_MemberUpdate_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_update_vec_push(v: *mut Vec_MemberUpdate_t, item: *mut MemberUpdate_t);
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_Member {
    #[doc = " <No documentation available>"]
    pub ptr: *mut Member_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_Member() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_Member> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_Member>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_Member))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_Member>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_Member))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_Member),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_Member),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_Member),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_Member {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_Member_t = Vec_Member;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_vec_as_slice(v: *const Vec_Member_t) -> slice_ref_Member_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_vec_as_slice_mut(v: *mut Vec_Member_t) -> slice_mut_Member_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_vec_free(_v: Vec_Member_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_vec_new() -> Vec_Member_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn member_vec_push(v: *mut Vec_Member_t, item: *mut Member_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct MessageKeyData {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  AEAD key derived by the MLS secret tree."]
pub type MessageKeyData_t = MessageKeyData;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn message_key_data_clone(x: *const MessageKeyData_t) -> *mut MessageKeyData_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn message_key_data_free(_x: *mut MessageKeyData_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn message_key_data_generation(__safer_ffi_gen_self: *const MessageKeyData_t) -> u32;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn message_key_data_key(__safer_ffi_gen_self: *const MessageKeyData_t)
        -> slice_ref_uint8_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn message_key_data_nonce(
        __safer_ffi_gen_self: *const MessageKeyData_t,
    ) -> slice_ref_uint8_t;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_MessageKeyData {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const MessageKeyData_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_MessageKeyData() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_MessageKeyData> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_MessageKeyData>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_MessageKeyData))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_MessageKeyData>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_MessageKeyData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_MessageKeyData),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_MessageKeyData),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_MessageKeyData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_MessageKeyData_t = slice_ref_MessageKeyData;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn message_key_data_slice_get(
        items: slice_ref_MessageKeyData_t,
        index: usize,
    ) -> *const MessageKeyData_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_MessageKeyData {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut MessageKeyData_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_MessageKeyData() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_MessageKeyData> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_MessageKeyData>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_MessageKeyData))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_MessageKeyData>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_MessageKeyData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_MessageKeyData),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_MessageKeyData),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_MessageKeyData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_MessageKeyData_t = slice_mut_MessageKeyData;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn message_key_data_slice_get_mut(
        items: slice_mut_MessageKeyData_t,
        index: usize,
    ) -> *mut MessageKeyData_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_MessageKeyData {
    #[doc = " <No documentation available>"]
    pub ptr: *mut MessageKeyData_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_MessageKeyData() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_MessageKeyData> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_MessageKeyData>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_MessageKeyData))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_MessageKeyData>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_MessageKeyData))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_MessageKeyData),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_MessageKeyData),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_MessageKeyData),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_MessageKeyData {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_MessageKeyData_t = Vec_MessageKeyData;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn message_key_data_vec_as_slice(
        v: *const Vec_MessageKeyData_t,
    ) -> slice_ref_MessageKeyData_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn message_key_data_vec_as_slice_mut(
        v: *mut Vec_MessageKeyData_t,
    ) -> slice_mut_MessageKeyData_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn message_key_data_vec_free(_v: Vec_MessageKeyData_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn message_key_data_vec_new() -> Vec_MessageKeyData_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn message_key_data_vec_push(v: *mut Vec_MessageKeyData_t, item: *mut MessageKeyData_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn mls_message_clone(x: *const MlsMessage_t) -> *mut MlsMessage_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_CustomProposal_const_ptr {
    #[doc = " <No documentation available>"]
    pub ptr: *mut *const CustomProposal_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_CustomProposal_const_ptr() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_CustomProposal_const_ptr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_CustomProposal_const_ptr>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_CustomProposal_const_ptr))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_CustomProposal_const_ptr>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_CustomProposal_const_ptr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_CustomProposal_const_ptr),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_CustomProposal_const_ptr),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_CustomProposal_const_ptr),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_CustomProposal_const_ptr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_CustomProposal_const_ptr_t = Vec_CustomProposal_const_ptr;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn mls_message_custom_proposals_by_value(
        __safer_ffi_gen_self: *const MlsMessage_t,
    ) -> Vec_CustomProposal_const_ptr_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn mls_message_free(_x: *mut MlsMessage_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn mls_message_from_bytes(
        bytes: slice_ref_uint8_t,
        __safer_ffi_gen_out: *mut *mut MlsMessage_t,
    ) -> i32;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn mls_message_group_id(__safer_ffi_gen_self: *const MlsMessage_t) -> slice_ref_uint8_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn mls_message_into_group_info(__safer_ffi_gen_self: *mut MlsMessage_t)
        -> *mut GroupInfo_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn mls_message_into_key_package(
        __safer_ffi_gen_self: *mut MlsMessage_t,
    ) -> *mut KeyPackage_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn mls_message_slice_get(
        items: slice_ref_MlsMessage_t,
        index: usize,
    ) -> *const MlsMessage_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_MlsMessage {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut MlsMessage_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_MlsMessage() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_MlsMessage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_MlsMessage>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_MlsMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_MlsMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_MlsMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_MlsMessage),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_MlsMessage),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_MlsMessage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_MlsMessage_t = slice_mut_MlsMessage;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn mls_message_slice_get_mut(
        items: slice_mut_MlsMessage_t,
        index: usize,
    ) -> *mut MlsMessage_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn mls_message_to_bytes(
        __safer_ffi_gen_self: *const MlsMessage_t,
        __safer_ffi_gen_out: *mut Vec_uint8_t,
    ) -> i32;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_MlsMessage {
    #[doc = " <No documentation available>"]
    pub ptr: *mut MlsMessage_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_MlsMessage() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_MlsMessage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_MlsMessage>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_MlsMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_MlsMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_MlsMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_MlsMessage),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_MlsMessage),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_MlsMessage),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_MlsMessage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_MlsMessage_t = Vec_MlsMessage;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn mls_message_vec_as_slice(v: *const Vec_MlsMessage_t) -> slice_ref_MlsMessage_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn mls_message_vec_as_slice_mut(v: *mut Vec_MlsMessage_t) -> slice_mut_MlsMessage_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn mls_message_vec_free(_v: Vec_MlsMessage_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn mls_message_vec_new() -> Vec_MlsMessage_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn mls_message_vec_push(v: *mut Vec_MlsMessage_t, item: *mut MlsMessage_t);
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_KeyPackageRef_const_ptr {
    #[doc = " <No documentation available>"]
    pub ptr: *mut *const KeyPackageRef_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_KeyPackageRef_const_ptr() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_KeyPackageRef_const_ptr> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_KeyPackageRef_const_ptr>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_KeyPackageRef_const_ptr))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_KeyPackageRef_const_ptr>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_KeyPackageRef_const_ptr))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_KeyPackageRef_const_ptr),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_KeyPackageRef_const_ptr),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_KeyPackageRef_const_ptr),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_KeyPackageRef_const_ptr {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_KeyPackageRef_const_ptr_t = Vec_KeyPackageRef_const_ptr;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn mls_message_welcome_key_package_references(
        __safer_ffi_gen_self: *const MlsMessage_t,
    ) -> Vec_KeyPackageRef_const_ptr_t;
}
#[doc = " <No documentation available>"]
pub const WireFormat_WIRE_FORMAT_PUBLIC_MESSAGE: WireFormat = 1;
#[doc = " <No documentation available>"]
pub const WireFormat_WIRE_FORMAT_PRIVATE_MESSAGE: WireFormat = 2;
#[doc = " <No documentation available>"]
pub const WireFormat_WIRE_FORMAT_WELCOME: WireFormat = 3;
#[doc = " <No documentation available>"]
pub const WireFormat_WIRE_FORMAT_GROUP_INFO: WireFormat = 4;
#[doc = " <No documentation available>"]
pub const WireFormat_WIRE_FORMAT_KEY_PACKAGE: WireFormat = 5;
pub type WireFormat = ::std::os::raw::c_uint;
pub type WireFormat_t = u16;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn mls_message_wire_format(__safer_ffi_gen_self: *const MlsMessage_t) -> WireFormat_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn mls_time_free(_x: u64);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct NewMemberInfo {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  Information provided to new members upon joining a group."]
pub type NewMemberInfo_t = NewMemberInfo;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn new_member_info_clone(x: *const NewMemberInfo_t) -> *mut NewMemberInfo_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn new_member_info_free(_x: *mut NewMemberInfo_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn new_member_info_group_info_extensions(
        __safer_ffi_gen_self: *const NewMemberInfo_t,
    ) -> *const ExtensionList_t;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_NewMemberInfo {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const NewMemberInfo_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_NewMemberInfo() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_NewMemberInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_NewMemberInfo>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_NewMemberInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_NewMemberInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_NewMemberInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_NewMemberInfo),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_NewMemberInfo),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_NewMemberInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_NewMemberInfo_t = slice_ref_NewMemberInfo;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn new_member_info_slice_get(
        items: slice_ref_NewMemberInfo_t,
        index: usize,
    ) -> *const NewMemberInfo_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_NewMemberInfo {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut NewMemberInfo_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_NewMemberInfo() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_NewMemberInfo> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_NewMemberInfo>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_NewMemberInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_NewMemberInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_NewMemberInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_NewMemberInfo),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_NewMemberInfo),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_NewMemberInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_NewMemberInfo_t = slice_mut_NewMemberInfo;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn new_member_info_slice_get_mut(
        items: slice_mut_NewMemberInfo_t,
        index: usize,
    ) -> *mut NewMemberInfo_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_NewMemberInfo {
    #[doc = " <No documentation available>"]
    pub ptr: *mut NewMemberInfo_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_NewMemberInfo() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_NewMemberInfo> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_NewMemberInfo>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_NewMemberInfo))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_NewMemberInfo>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_NewMemberInfo))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_NewMemberInfo),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_NewMemberInfo),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_NewMemberInfo),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_NewMemberInfo {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_NewMemberInfo_t = Vec_NewMemberInfo;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn new_member_info_vec_as_slice(v: *const Vec_NewMemberInfo_t)
        -> slice_ref_NewMemberInfo_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn new_member_info_vec_as_slice_mut(
        v: *mut Vec_NewMemberInfo_t,
    ) -> slice_mut_NewMemberInfo_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn new_member_info_vec_free(_v: Vec_NewMemberInfo_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn new_member_info_vec_new() -> Vec_NewMemberInfo_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn new_member_info_vec_push(v: *mut Vec_NewMemberInfo_t, item: *mut NewMemberInfo_t);
}
#[doc = " \\brief\n  Step function based on the size of the message being sent.\n  The amount of padding used will increase with the size of the original\n  message."]
pub const PaddingMode_PADDING_MODE_STEP_FUNCTION: PaddingMode = 0;
#[doc = " \\brief\n  No padding."]
pub const PaddingMode_PADDING_MODE_NONE: PaddingMode = 1;
pub type PaddingMode = ::std::os::raw::c_uint;
pub type PaddingMode_t = u8;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn padding_mode_free(_x: PaddingMode_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_info_ffi_is_by_reference(
        __safer_ffi_gen_self: *const ProposalInfo_Proposal_t,
    ) -> bool;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_info_ffi_is_by_value(
        __safer_ffi_gen_self: *const ProposalInfo_Proposal_t,
    ) -> bool;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProposalRef {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  Unique identifier for a proposal message."]
pub type ProposalRef_t = ProposalRef;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_info_ffi_proposal_ref(
        __safer_ffi_gen_self: *const ProposalInfo_Proposal_t,
    ) -> *const ProposalRef_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Sender {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  The layout of mls_rs::group::framing::Sender is subject to change"]
pub type Sender_t = Sender;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_info_ffi_sender(
        __safer_ffi_gen_self: *const ProposalInfo_Proposal_t,
    ) -> *const Sender_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProposalSource {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  The layout of mls_rs::group::proposal_filter::bundle::ProposalSource is subject to change"]
pub type ProposalSource_t = ProposalSource;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_info_ffi_source(
        __safer_ffi_gen_self: *const ProposalInfo_Proposal_t,
    ) -> *const ProposalSource_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ProposalMessageDescription {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  Description of a processed MLS proposal message."]
pub type ProposalMessageDescription_t = ProposalMessageDescription;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_message_description_clone(
        x: *const ProposalMessageDescription_t,
    ) -> *mut ProposalMessageDescription_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_message_description_free(_x: *mut ProposalMessageDescription_t);
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_ProposalMessageDescription {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const ProposalMessageDescription_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_ProposalMessageDescription() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_ProposalMessageDescription> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_ProposalMessageDescription>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(slice_ref_ProposalMessageDescription)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_ProposalMessageDescription>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(slice_ref_ProposalMessageDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_ProposalMessageDescription),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_ProposalMessageDescription),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_ProposalMessageDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_ProposalMessageDescription_t = slice_ref_ProposalMessageDescription;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_message_description_slice_get(
        items: slice_ref_ProposalMessageDescription_t,
        index: usize,
    ) -> *const ProposalMessageDescription_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_ProposalMessageDescription {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut ProposalMessageDescription_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_ProposalMessageDescription() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_ProposalMessageDescription> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_ProposalMessageDescription>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(slice_mut_ProposalMessageDescription)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_ProposalMessageDescription>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(slice_mut_ProposalMessageDescription)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_ProposalMessageDescription),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_ProposalMessageDescription),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_ProposalMessageDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_ProposalMessageDescription_t = slice_mut_ProposalMessageDescription;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_message_description_slice_get_mut(
        items: slice_mut_ProposalMessageDescription_t,
        index: usize,
    ) -> *mut ProposalMessageDescription_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_ProposalMessageDescription {
    #[doc = " <No documentation available>"]
    pub ptr: *mut ProposalMessageDescription_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_ProposalMessageDescription() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_ProposalMessageDescription> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_ProposalMessageDescription>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_ProposalMessageDescription))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_ProposalMessageDescription>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_ProposalMessageDescription))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ProposalMessageDescription),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ProposalMessageDescription),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ProposalMessageDescription),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_ProposalMessageDescription {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_ProposalMessageDescription_t = Vec_ProposalMessageDescription;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_message_description_vec_as_slice(
        v: *const Vec_ProposalMessageDescription_t,
    ) -> slice_ref_ProposalMessageDescription_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_message_description_vec_as_slice_mut(
        v: *mut Vec_ProposalMessageDescription_t,
    ) -> slice_mut_ProposalMessageDescription_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_message_description_vec_free(_v: Vec_ProposalMessageDescription_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_message_description_vec_new() -> Vec_ProposalMessageDescription_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_message_description_vec_push(
        v: *mut Vec_ProposalMessageDescription_t,
        item: *mut ProposalMessageDescription_t,
    );
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_ref_as_slice(__safer_ffi_gen_self: *const ProposalRef_t) -> slice_ref_uint8_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_ref_clone(x: *const ProposalRef_t) -> *mut ProposalRef_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_ref_free(_x: *mut ProposalRef_t);
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_ProposalRef {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const ProposalRef_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_ProposalRef() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_ProposalRef> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_ProposalRef>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_ProposalRef))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_ProposalRef>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_ProposalRef))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_ProposalRef),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_ProposalRef),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_ProposalRef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_ProposalRef_t = slice_ref_ProposalRef;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_ref_slice_get(
        items: slice_ref_ProposalRef_t,
        index: usize,
    ) -> *const ProposalRef_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_ProposalRef {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut ProposalRef_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_ProposalRef() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_ProposalRef> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_ProposalRef>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_ProposalRef))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_ProposalRef>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_ProposalRef))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_ProposalRef),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_ProposalRef),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_ProposalRef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_ProposalRef_t = slice_mut_ProposalRef;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_ref_slice_get_mut(
        items: slice_mut_ProposalRef_t,
        index: usize,
    ) -> *mut ProposalRef_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_ProposalRef {
    #[doc = " <No documentation available>"]
    pub ptr: *mut ProposalRef_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_ProposalRef() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_ProposalRef> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_ProposalRef>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_ProposalRef))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_ProposalRef>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_ProposalRef))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ProposalRef),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ProposalRef),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ProposalRef),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_ProposalRef {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_ProposalRef_t = Vec_ProposalRef;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_ref_vec_as_slice(v: *const Vec_ProposalRef_t) -> slice_ref_ProposalRef_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_ref_vec_as_slice_mut(v: *mut Vec_ProposalRef_t) -> slice_mut_ProposalRef_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_ref_vec_free(_v: Vec_ProposalRef_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_ref_vec_new() -> Vec_ProposalRef_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_ref_vec_push(v: *mut Vec_ProposalRef_t, item: *mut ProposalRef_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_source_clone(x: *const ProposalSource_t) -> *mut ProposalSource_t;
}
#[doc = " <No documentation available>"]
pub const ProposalSourceDiscriminant_PROPOSAL_SOURCE_DISCRIMINANT_BY_VALUE:
    ProposalSourceDiscriminant = 0;
#[doc = " <No documentation available>"]
pub const ProposalSourceDiscriminant_PROPOSAL_SOURCE_DISCRIMINANT_BY_REFERENCE:
    ProposalSourceDiscriminant = 1;
#[doc = " <No documentation available>"]
pub const ProposalSourceDiscriminant_PROPOSAL_SOURCE_DISCRIMINANT_LOCAL:
    ProposalSourceDiscriminant = 2;
pub type ProposalSourceDiscriminant = ::std::os::raw::c_uint;
pub type ProposalSourceDiscriminant_t = i32;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_source_discriminant(x: *const ProposalSource_t)
        -> ProposalSourceDiscriminant_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_source_free(_x: *mut ProposalSource_t);
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_ProposalSource {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const ProposalSource_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_ProposalSource() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_ProposalSource> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_ProposalSource>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_ProposalSource))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_ProposalSource>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_ProposalSource))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_ProposalSource),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_ProposalSource),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_ProposalSource {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_ProposalSource_t = slice_ref_ProposalSource;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_source_slice_get(
        items: slice_ref_ProposalSource_t,
        index: usize,
    ) -> *const ProposalSource_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_ProposalSource {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut ProposalSource_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_ProposalSource() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_ProposalSource> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_ProposalSource>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_ProposalSource))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_ProposalSource>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_ProposalSource))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_ProposalSource),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_ProposalSource),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_ProposalSource {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_ProposalSource_t = slice_mut_ProposalSource;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_source_slice_get_mut(
        items: slice_mut_ProposalSource_t,
        index: usize,
    ) -> *mut ProposalSource_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_source_to_by_reference(x: *const ProposalSource_t) -> *const ProposalRef_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_ProposalSource {
    #[doc = " <No documentation available>"]
    pub ptr: *mut ProposalSource_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_ProposalSource() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_ProposalSource> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_ProposalSource>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_ProposalSource))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_ProposalSource>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_ProposalSource))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ProposalSource),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ProposalSource),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ProposalSource),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_ProposalSource {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_ProposalSource_t = Vec_ProposalSource;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_source_vec_as_slice(
        v: *const Vec_ProposalSource_t,
    ) -> slice_ref_ProposalSource_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_source_vec_as_slice_mut(
        v: *mut Vec_ProposalSource_t,
    ) -> slice_mut_ProposalSource_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_source_vec_free(_v: Vec_ProposalSource_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_source_vec_new() -> Vec_ProposalSource_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_source_vec_push(v: *mut Vec_ProposalSource_t, item: *mut ProposalSource_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn proposal_type_free(_x: u16);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn protocol_version_free(_x: u16);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RatchetTreeExt {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  Representation of an MLS ratchet tree.\n\n  Used to provide new members\n  a copy of the current group state in-band."]
pub type RatchetTreeExt_t = RatchetTreeExt;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn ratchet_tree_ext_clone(x: *const RatchetTreeExt_t) -> *mut RatchetTreeExt_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn ratchet_tree_ext_free(_x: *mut RatchetTreeExt_t);
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_RatchetTreeExt {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const RatchetTreeExt_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_RatchetTreeExt() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_RatchetTreeExt> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_RatchetTreeExt>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_RatchetTreeExt))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_RatchetTreeExt>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_RatchetTreeExt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_RatchetTreeExt),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_RatchetTreeExt),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_RatchetTreeExt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_RatchetTreeExt_t = slice_ref_RatchetTreeExt;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn ratchet_tree_ext_slice_get(
        items: slice_ref_RatchetTreeExt_t,
        index: usize,
    ) -> *const RatchetTreeExt_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_RatchetTreeExt {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut RatchetTreeExt_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_RatchetTreeExt() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_RatchetTreeExt> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_RatchetTreeExt>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_RatchetTreeExt))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_RatchetTreeExt>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_RatchetTreeExt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_RatchetTreeExt),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_RatchetTreeExt),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_RatchetTreeExt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_RatchetTreeExt_t = slice_mut_RatchetTreeExt;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn ratchet_tree_ext_slice_get_mut(
        items: slice_mut_RatchetTreeExt_t,
        index: usize,
    ) -> *mut RatchetTreeExt_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn ratchet_tree_ext_tree_data(
        __safer_ffi_gen_self: *const RatchetTreeExt_t,
    ) -> *const ExportedTree_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_RatchetTreeExt {
    #[doc = " <No documentation available>"]
    pub ptr: *mut RatchetTreeExt_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_RatchetTreeExt() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_RatchetTreeExt> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_RatchetTreeExt>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_RatchetTreeExt))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_RatchetTreeExt>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_RatchetTreeExt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_RatchetTreeExt),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_RatchetTreeExt),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_RatchetTreeExt),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_RatchetTreeExt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_RatchetTreeExt_t = Vec_RatchetTreeExt;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn ratchet_tree_ext_vec_as_slice(
        v: *const Vec_RatchetTreeExt_t,
    ) -> slice_ref_RatchetTreeExt_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn ratchet_tree_ext_vec_as_slice_mut(
        v: *mut Vec_RatchetTreeExt_t,
    ) -> slice_mut_RatchetTreeExt_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn ratchet_tree_ext_vec_free(_v: Vec_RatchetTreeExt_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn ratchet_tree_ext_vec_new() -> Vec_RatchetTreeExt_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn ratchet_tree_ext_vec_push(v: *mut Vec_RatchetTreeExt_t, item: *mut RatchetTreeExt_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReceivedMessage {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  The layout of mls_rs::group::message_processor::ReceivedMessage is subject to change"]
pub type ReceivedMessage_t = ReceivedMessage;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn received_message_clone(x: *const ReceivedMessage_t) -> *mut ReceivedMessage_t;
}
#[doc = " <No documentation available>"]
pub const ReceivedMessageDiscriminant_RECEIVED_MESSAGE_DISCRIMINANT_APPLICATION_MESSAGE:
    ReceivedMessageDiscriminant = 0;
#[doc = " <No documentation available>"]
pub const ReceivedMessageDiscriminant_RECEIVED_MESSAGE_DISCRIMINANT_COMMIT:
    ReceivedMessageDiscriminant = 1;
#[doc = " <No documentation available>"]
pub const ReceivedMessageDiscriminant_RECEIVED_MESSAGE_DISCRIMINANT_PROPOSAL:
    ReceivedMessageDiscriminant = 2;
pub type ReceivedMessageDiscriminant = ::std::os::raw::c_uint;
pub type ReceivedMessageDiscriminant_t = i32;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn received_message_discriminant(
        x: *const ReceivedMessage_t,
    ) -> ReceivedMessageDiscriminant_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn received_message_free(_x: *mut ReceivedMessage_t);
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_ReceivedMessage {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const ReceivedMessage_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_ReceivedMessage() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_ReceivedMessage> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_ReceivedMessage>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_ReceivedMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_ReceivedMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_ReceivedMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_ReceivedMessage),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_ReceivedMessage),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_ReceivedMessage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_ReceivedMessage_t = slice_ref_ReceivedMessage;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn received_message_slice_get(
        items: slice_ref_ReceivedMessage_t,
        index: usize,
    ) -> *const ReceivedMessage_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_ReceivedMessage {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut ReceivedMessage_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_ReceivedMessage() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_ReceivedMessage> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_ReceivedMessage>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_ReceivedMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_ReceivedMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_ReceivedMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_ReceivedMessage),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_ReceivedMessage),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_ReceivedMessage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_ReceivedMessage_t = slice_mut_ReceivedMessage;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn received_message_slice_get_mut(
        items: slice_mut_ReceivedMessage_t,
        index: usize,
    ) -> *mut ReceivedMessage_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn received_message_to_application_message(
        x: *const ReceivedMessage_t,
    ) -> *const ApplicationMessageDescription_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn received_message_to_commit(
        x: *const ReceivedMessage_t,
    ) -> *const CommitMessageDescription_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn received_message_to_proposal(
        x: *const ReceivedMessage_t,
    ) -> *const ProposalMessageDescription_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_ReceivedMessage {
    #[doc = " <No documentation available>"]
    pub ptr: *mut ReceivedMessage_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_ReceivedMessage() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_ReceivedMessage> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_ReceivedMessage>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_ReceivedMessage))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_ReceivedMessage>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_ReceivedMessage))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ReceivedMessage),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ReceivedMessage),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_ReceivedMessage),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_ReceivedMessage {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_ReceivedMessage_t = Vec_ReceivedMessage;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn received_message_vec_as_slice(
        v: *const Vec_ReceivedMessage_t,
    ) -> slice_ref_ReceivedMessage_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn received_message_vec_as_slice_mut(
        v: *mut Vec_ReceivedMessage_t,
    ) -> slice_mut_ReceivedMessage_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn received_message_vec_free(_v: Vec_ReceivedMessage_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn received_message_vec_new() -> Vec_ReceivedMessage_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn received_message_vec_push(v: *mut Vec_ReceivedMessage_t, item: *mut ReceivedMessage_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RequiredCapabilitiesExt {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  Require members to have certain capabilities.\n\n  Used within a\n  [Group Context Extensions Proposal](crate::group::proposal::Proposal)\n  in order to require that all current and future members of a group MUST\n  support specific extensions, proposals, or credentials.\n\n  # Warning\n\n  Extension, proposal, and credential types defined by the MLS RFC and\n  provided are considered required by default and should NOT be used\n  within this extension."]
pub type RequiredCapabilitiesExt_t = RequiredCapabilitiesExt;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn required_capabilities_ext_clone(
        x: *const RequiredCapabilitiesExt_t,
    ) -> *mut RequiredCapabilitiesExt_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn required_capabilities_ext_credentials(
        __safer_ffi_gen_self: *const RequiredCapabilitiesExt_t,
    ) -> slice_ref_uint16_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn required_capabilities_ext_extensions(
        __safer_ffi_gen_self: *const RequiredCapabilitiesExt_t,
    ) -> slice_ref_uint16_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn required_capabilities_ext_free(_x: *mut RequiredCapabilitiesExt_t);
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_uint16 {
    #[doc = " <No documentation available>"]
    pub ptr: *mut u16,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_uint16() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_uint16> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_uint16>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_uint16))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_uint16>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_uint16))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_uint16),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_uint16),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_uint16),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_uint16 {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_uint16_t = Vec_uint16;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn required_capabilities_ext_new(
        extensions: Vec_uint16_t,
        proposals: Vec_uint16_t,
        credentials: Vec_uint16_t,
    ) -> *mut RequiredCapabilitiesExt_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn required_capabilities_ext_proposals(
        __safer_ffi_gen_self: *const RequiredCapabilitiesExt_t,
    ) -> slice_ref_uint16_t;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_RequiredCapabilitiesExt {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const RequiredCapabilitiesExt_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_RequiredCapabilitiesExt() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_RequiredCapabilitiesExt> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_RequiredCapabilitiesExt>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_RequiredCapabilitiesExt))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_RequiredCapabilitiesExt>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(slice_ref_RequiredCapabilitiesExt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_RequiredCapabilitiesExt),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_RequiredCapabilitiesExt),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_RequiredCapabilitiesExt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_RequiredCapabilitiesExt_t = slice_ref_RequiredCapabilitiesExt;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn required_capabilities_ext_slice_get(
        items: slice_ref_RequiredCapabilitiesExt_t,
        index: usize,
    ) -> *const RequiredCapabilitiesExt_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_RequiredCapabilitiesExt {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut RequiredCapabilitiesExt_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_RequiredCapabilitiesExt() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_RequiredCapabilitiesExt> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_RequiredCapabilitiesExt>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_RequiredCapabilitiesExt))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_RequiredCapabilitiesExt>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(slice_mut_RequiredCapabilitiesExt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_RequiredCapabilitiesExt),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_RequiredCapabilitiesExt),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_RequiredCapabilitiesExt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_RequiredCapabilitiesExt_t = slice_mut_RequiredCapabilitiesExt;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn required_capabilities_ext_slice_get_mut(
        items: slice_mut_RequiredCapabilitiesExt_t,
        index: usize,
    ) -> *mut RequiredCapabilitiesExt_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_RequiredCapabilitiesExt {
    #[doc = " <No documentation available>"]
    pub ptr: *mut RequiredCapabilitiesExt_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_RequiredCapabilitiesExt() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_RequiredCapabilitiesExt> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_RequiredCapabilitiesExt>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_RequiredCapabilitiesExt))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_RequiredCapabilitiesExt>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_RequiredCapabilitiesExt))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_RequiredCapabilitiesExt),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_RequiredCapabilitiesExt),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_RequiredCapabilitiesExt),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_RequiredCapabilitiesExt {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_RequiredCapabilitiesExt_t = Vec_RequiredCapabilitiesExt;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn required_capabilities_ext_vec_as_slice(
        v: *const Vec_RequiredCapabilitiesExt_t,
    ) -> slice_ref_RequiredCapabilitiesExt_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn required_capabilities_ext_vec_as_slice_mut(
        v: *mut Vec_RequiredCapabilitiesExt_t,
    ) -> slice_mut_RequiredCapabilitiesExt_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn required_capabilities_ext_vec_free(_v: Vec_RequiredCapabilitiesExt_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn required_capabilities_ext_vec_new() -> Vec_RequiredCapabilitiesExt_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn required_capabilities_ext_vec_push(
        v: *mut Vec_RequiredCapabilitiesExt_t,
        item: *mut RequiredCapabilitiesExt_t,
    );
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn roster_clone(x: *const Roster_t) -> *mut Roster_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn roster_free(_x: *mut Roster_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn roster_member_with_index(
        __safer_ffi_gen_self: *const Roster_t,
        index: u32,
        __safer_ffi_gen_out: *mut *mut Member_t,
    ) -> i32;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn roster_members(__safer_ffi_gen_self: *const Roster_t) -> Vec_Member_t;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_Roster {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const Roster_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_Roster() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_Roster> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_Roster>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_Roster))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_Roster>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_Roster))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_Roster),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_Roster),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_Roster {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_Roster_t = slice_ref_Roster;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn roster_slice_get(items: slice_ref_Roster_t, index: usize) -> *const Roster_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_Roster {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut Roster_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_Roster() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_Roster> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_Roster>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_Roster))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_Roster>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_Roster))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_Roster),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_Roster),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_Roster {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_Roster_t = slice_mut_Roster;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn roster_slice_get_mut(items: slice_mut_Roster_t, index: usize) -> *mut Roster_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_Roster {
    #[doc = " <No documentation available>"]
    pub ptr: *mut Roster_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_Roster() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_Roster> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_Roster>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_Roster))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_Roster>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_Roster))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_Roster),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_Roster),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_Roster),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_Roster {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_Roster_t = Vec_Roster;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn roster_vec_as_slice(v: *const Vec_Roster_t) -> slice_ref_Roster_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn roster_vec_as_slice_mut(v: *mut Vec_Roster_t) -> slice_mut_Roster_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn roster_vec_free(_v: Vec_Roster_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn roster_vec_new() -> Vec_Roster_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn roster_vec_push(v: *mut Vec_Roster_t, item: *mut Roster_t);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Secret {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  Wrapper struct that represents a zeroize-on-drop `Vec<u8>`"]
pub type Secret_t = Secret;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn secret_as_bytes(__safer_ffi_gen_self: *const Secret_t) -> slice_ref_uint8_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn secret_clone(x: *const Secret_t) -> *mut Secret_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn secret_free(_x: *mut Secret_t);
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_Secret {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const Secret_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_Secret() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_Secret> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_Secret>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_Secret))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_Secret>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_Secret))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_Secret),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_Secret),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_Secret {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_Secret_t = slice_ref_Secret;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn secret_slice_get(items: slice_ref_Secret_t, index: usize) -> *const Secret_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_Secret {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut Secret_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_Secret() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_Secret> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_Secret>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_Secret))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_Secret>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_Secret))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_Secret),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_Secret),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_Secret {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_Secret_t = slice_mut_Secret;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn secret_slice_get_mut(items: slice_mut_Secret_t, index: usize) -> *mut Secret_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_Secret {
    #[doc = " <No documentation available>"]
    pub ptr: *mut Secret_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_Secret() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_Secret> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_Secret>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_Secret))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_Secret>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_Secret))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_Secret),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_Secret),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_Secret),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_Secret {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_Secret_t = Vec_Secret;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn secret_vec_as_slice(v: *const Vec_Secret_t) -> slice_ref_Secret_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn secret_vec_as_slice_mut(v: *mut Vec_Secret_t) -> slice_mut_Secret_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn secret_vec_free(_v: Vec_Secret_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn secret_vec_new() -> Vec_Secret_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn secret_vec_push(v: *mut Vec_Secret_t, item: *mut Secret_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn sender_clone(x: *const Sender_t) -> *mut Sender_t;
}
#[doc = " <No documentation available>"]
pub const SenderDiscriminant_SENDER_DISCRIMINANT_MEMBER: SenderDiscriminant = 1;
#[doc = " <No documentation available>"]
pub const SenderDiscriminant_SENDER_DISCRIMINANT_EXTERNAL: SenderDiscriminant = 2;
#[doc = " <No documentation available>"]
pub const SenderDiscriminant_SENDER_DISCRIMINANT_NEW_MEMBER_PROPOSAL: SenderDiscriminant = 3;
#[doc = " <No documentation available>"]
pub const SenderDiscriminant_SENDER_DISCRIMINANT_NEW_MEMBER_COMMIT: SenderDiscriminant = 4;
pub type SenderDiscriminant = ::std::os::raw::c_uint;
pub type SenderDiscriminant_t = u8;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn sender_discriminant(x: *const Sender_t) -> SenderDiscriminant_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn sender_free(_x: *mut Sender_t);
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_Sender {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const Sender_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_Sender() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_Sender> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_Sender>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_Sender))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_Sender>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_Sender))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_Sender),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_Sender),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_Sender {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_Sender_t = slice_ref_Sender;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn sender_slice_get(items: slice_ref_Sender_t, index: usize) -> *const Sender_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_Sender {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut Sender_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_Sender() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_Sender> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_Sender>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_Sender))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_Sender>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_Sender))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_Sender),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_Sender),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_Sender {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_Sender_t = slice_mut_Sender;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn sender_slice_get_mut(items: slice_mut_Sender_t, index: usize) -> *mut Sender_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn sender_to_external(x: *const Sender_t) -> *const u32;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn sender_to_member(x: *const Sender_t) -> *const u32;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_Sender {
    #[doc = " <No documentation available>"]
    pub ptr: *mut Sender_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_Sender() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_Sender> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_Sender>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_Sender))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_Sender>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_Sender))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_Sender),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_Sender),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_Sender),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_Sender {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_Sender_t = Vec_Sender;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn sender_vec_as_slice(v: *const Vec_Sender_t) -> slice_ref_Sender_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn sender_vec_as_slice_mut(v: *mut Vec_Sender_t) -> slice_mut_Sender_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn sender_vec_free(_v: Vec_Sender_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn sender_vec_new() -> Vec_Sender_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn sender_vec_push(v: *mut Vec_Sender_t, item: *mut Sender_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_keypair_free(_x: *mut SignatureKeypair_t);
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_SignatureKeypair {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const SignatureKeypair_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_SignatureKeypair() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_SignatureKeypair> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_SignatureKeypair>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_SignatureKeypair))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_SignatureKeypair>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_SignatureKeypair))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_SignatureKeypair),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_SignatureKeypair),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_SignatureKeypair {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_SignatureKeypair_t = slice_ref_SignatureKeypair;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_keypair_slice_get(
        items: slice_ref_SignatureKeypair_t,
        index: usize,
    ) -> *const SignatureKeypair_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_SignatureKeypair {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut SignatureKeypair_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_SignatureKeypair() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_SignatureKeypair> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_SignatureKeypair>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_SignatureKeypair))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_SignatureKeypair>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_SignatureKeypair))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_SignatureKeypair),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_SignatureKeypair),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_SignatureKeypair {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_SignatureKeypair_t = slice_mut_SignatureKeypair;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_keypair_slice_get_mut(
        items: slice_mut_SignatureKeypair_t,
        index: usize,
    ) -> *mut SignatureKeypair_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_SignatureKeypair {
    #[doc = " <No documentation available>"]
    pub ptr: *mut SignatureKeypair_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_SignatureKeypair() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_SignatureKeypair> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_SignatureKeypair>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_SignatureKeypair))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_SignatureKeypair>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_SignatureKeypair))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_SignatureKeypair),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_SignatureKeypair),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_SignatureKeypair),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_SignatureKeypair {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_SignatureKeypair_t = Vec_SignatureKeypair;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_keypair_vec_as_slice(
        v: *const Vec_SignatureKeypair_t,
    ) -> slice_ref_SignatureKeypair_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_keypair_vec_as_slice_mut(
        v: *mut Vec_SignatureKeypair_t,
    ) -> slice_mut_SignatureKeypair_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_keypair_vec_free(_v: Vec_SignatureKeypair_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_keypair_vec_new() -> Vec_SignatureKeypair_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_keypair_vec_push(
        v: *mut Vec_SignatureKeypair_t,
        item: *mut SignatureKeypair_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SignaturePublicKey {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  Byte representation of a signature public key. For ciphersuites using elliptic curves,\n  the public key should be represented in the uncompressed format."]
pub type SignaturePublicKey_t = SignaturePublicKey;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_public_key_as_bytes(
        __safer_ffi_gen_self: *const SignaturePublicKey_t,
    ) -> slice_ref_uint8_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_public_key_free(_x: *mut SignaturePublicKey_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_public_key_new(bytes: Vec_uint8_t) -> *mut SignaturePublicKey_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_public_key_new_slice(data: slice_ref_uint8_t) -> *mut SignaturePublicKey_t;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_SignaturePublicKey {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const SignaturePublicKey_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_SignaturePublicKey() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_SignaturePublicKey> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_SignaturePublicKey>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_SignaturePublicKey))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_SignaturePublicKey>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_SignaturePublicKey))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_SignaturePublicKey),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_SignaturePublicKey),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_SignaturePublicKey {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_SignaturePublicKey_t = slice_ref_SignaturePublicKey;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_public_key_slice_get(
        items: slice_ref_SignaturePublicKey_t,
        index: usize,
    ) -> *const SignaturePublicKey_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_SignaturePublicKey {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut SignaturePublicKey_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_SignaturePublicKey() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_SignaturePublicKey> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_SignaturePublicKey>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_SignaturePublicKey))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_SignaturePublicKey>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_SignaturePublicKey))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_SignaturePublicKey),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_SignaturePublicKey),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_SignaturePublicKey {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_SignaturePublicKey_t = slice_mut_SignaturePublicKey;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_public_key_slice_get_mut(
        items: slice_mut_SignaturePublicKey_t,
        index: usize,
    ) -> *mut SignaturePublicKey_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_SignaturePublicKey {
    #[doc = " <No documentation available>"]
    pub ptr: *mut SignaturePublicKey_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_SignaturePublicKey() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_SignaturePublicKey> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_SignaturePublicKey>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_SignaturePublicKey))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_SignaturePublicKey>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_SignaturePublicKey))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_SignaturePublicKey),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_SignaturePublicKey),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_SignaturePublicKey),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_SignaturePublicKey {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_SignaturePublicKey_t = Vec_SignaturePublicKey;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_public_key_vec_as_slice(
        v: *const Vec_SignaturePublicKey_t,
    ) -> slice_ref_SignaturePublicKey_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_public_key_vec_as_slice_mut(
        v: *mut Vec_SignaturePublicKey_t,
    ) -> slice_mut_SignaturePublicKey_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_public_key_vec_free(_v: Vec_SignaturePublicKey_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_public_key_vec_new() -> Vec_SignaturePublicKey_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_public_key_vec_push(
        v: *mut Vec_SignaturePublicKey_t,
        item: *mut SignaturePublicKey_t,
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SignatureSecretKey {
    _unused: [u8; 0],
}
#[doc = " \\brief\n  Byte representation of a signature key."]
pub type SignatureSecretKey_t = SignatureSecretKey;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_secret_key_as_bytes(
        __safer_ffi_gen_self: *const SignatureSecretKey_t,
    ) -> slice_ref_uint8_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_secret_key_clone(x: *const SignatureSecretKey_t) -> *mut SignatureSecretKey_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_secret_key_free(_x: *mut SignatureSecretKey_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_secret_key_new(bytes: Vec_uint8_t) -> *mut SignatureSecretKey_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_secret_key_new_slice(data: slice_ref_uint8_t) -> *mut SignatureSecretKey_t;
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_ref_SignatureSecretKey {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *const SignatureSecretKey_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_ref_SignatureSecretKey() {
    const UNINIT: ::std::mem::MaybeUninit<slice_ref_SignatureSecretKey> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_ref_SignatureSecretKey>(),
        16usize,
        concat!("Size of: ", stringify!(slice_ref_SignatureSecretKey))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_ref_SignatureSecretKey>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_ref_SignatureSecretKey))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_SignatureSecretKey),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_ref_SignatureSecretKey),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_ref_SignatureSecretKey {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_ref_SignatureSecretKey_t = slice_ref_SignatureSecretKey;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_secret_key_slice_get(
        items: slice_ref_SignatureSecretKey_t,
        index: usize,
    ) -> *const SignatureSecretKey_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_SignatureSecretKey {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut SignatureSecretKey_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_SignatureSecretKey() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_SignatureSecretKey> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_SignatureSecretKey>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_SignatureSecretKey))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_SignatureSecretKey>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_SignatureSecretKey))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_SignatureSecretKey),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_SignatureSecretKey),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_SignatureSecretKey {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_SignatureSecretKey_t = slice_mut_SignatureSecretKey;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_secret_key_slice_get_mut(
        items: slice_mut_SignatureSecretKey_t,
        index: usize,
    ) -> *mut SignatureSecretKey_t;
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Vec_SignatureSecretKey {
    #[doc = " <No documentation available>"]
    pub ptr: *mut SignatureSecretKey_t,
    #[doc = " <No documentation available>"]
    pub len: usize,
    #[doc = " <No documentation available>"]
    pub cap: usize,
}
#[test]
fn bindgen_test_layout_Vec_SignatureSecretKey() {
    const UNINIT: ::std::mem::MaybeUninit<Vec_SignatureSecretKey> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Vec_SignatureSecretKey>(),
        24usize,
        concat!("Size of: ", stringify!(Vec_SignatureSecretKey))
    );
    assert_eq!(
        ::std::mem::align_of::<Vec_SignatureSecretKey>(),
        8usize,
        concat!("Alignment of ", stringify!(Vec_SignatureSecretKey))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_SignatureSecretKey),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_SignatureSecretKey),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).cap) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Vec_SignatureSecretKey),
            "::",
            stringify!(cap)
        )
    );
}
impl Default for Vec_SignatureSecretKey {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout"]
pub type Vec_SignatureSecretKey_t = Vec_SignatureSecretKey;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_secret_key_vec_as_slice(
        v: *const Vec_SignatureSecretKey_t,
    ) -> slice_ref_SignatureSecretKey_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_secret_key_vec_as_slice_mut(
        v: *mut Vec_SignatureSecretKey_t,
    ) -> slice_mut_SignatureSecretKey_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_secret_key_vec_free(_v: Vec_SignatureSecretKey_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_secret_key_vec_new() -> Vec_SignatureSecretKey_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signature_secret_key_vec_push(
        v: *mut Vec_SignatureSecretKey_t,
        item: *mut SignatureSecretKey_t,
    );
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signing_identity_clone(x: *const SigningIdentity_t) -> *mut SigningIdentity_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signing_identity_free(_x: *mut SigningIdentity_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signing_identity_slice_get(
        items: slice_ref_SigningIdentity_t,
        index: usize,
    ) -> *const SigningIdentity_t;
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct slice_mut_SigningIdentity {
    #[doc = " \\brief\n  Pointer to the first element (if any)."]
    pub ptr: *mut SigningIdentity_t,
    #[doc = " \\brief\n  Element count"]
    pub len: usize,
}
#[test]
fn bindgen_test_layout_slice_mut_SigningIdentity() {
    const UNINIT: ::std::mem::MaybeUninit<slice_mut_SigningIdentity> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<slice_mut_SigningIdentity>(),
        16usize,
        concat!("Size of: ", stringify!(slice_mut_SigningIdentity))
    );
    assert_eq!(
        ::std::mem::align_of::<slice_mut_SigningIdentity>(),
        8usize,
        concat!("Alignment of ", stringify!(slice_mut_SigningIdentity))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ptr) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_SigningIdentity),
            "::",
            stringify!(ptr)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).len) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(slice_mut_SigningIdentity),
            "::",
            stringify!(len)
        )
    );
}
impl Default for slice_mut_SigningIdentity {
    fn default() -> Self {
        let mut s = ::std::mem::MaybeUninit::<Self>::uninit();
        unsafe {
            ::std::ptr::write_bytes(s.as_mut_ptr(), 0, 1);
            s.assume_init()
        }
    }
}
#[doc = " \\brief\n  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.\n\n  # C layout (for some given type T)\n\n  ```c\n  typedef struct {\n  // Cannot be NULL\n  T * ptr;\n  size_t len;\n  } slice_T;\n  ```\n\n  # Nullable pointer?\n\n  If you want to support the above typedef, but where the `ptr` field is\n  allowed to be `NULL` (with the contents of `len` then being undefined)\n  use the `Option< slice_ptr<_> >` type."]
pub type slice_mut_SigningIdentity_t = slice_mut_SigningIdentity;
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signing_identity_slice_get_mut(
        items: slice_mut_SigningIdentity_t,
        index: usize,
    ) -> *mut SigningIdentity_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signing_identity_vec_as_slice(
        v: *const Vec_SigningIdentity_t,
    ) -> slice_ref_SigningIdentity_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signing_identity_vec_as_slice_mut(
        v: *mut Vec_SigningIdentity_t,
    ) -> slice_mut_SigningIdentity_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signing_identity_vec_free(_v: Vec_SigningIdentity_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signing_identity_vec_new() -> Vec_SigningIdentity_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn signing_identity_vec_push(v: *mut Vec_SigningIdentity_t, item: *mut SigningIdentity_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn vec_u8_free(_v: Vec_uint8_t);
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn vec_u8_from_slice(bytes: slice_ref_uint8_t) -> Vec_uint8_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn vec_u8_new(length: usize) -> Vec_uint8_t;
}
extern "C" {
    #[doc = " <No documentation available>"]
    pub fn wire_format_free(_x: WireFormat_t);
}
