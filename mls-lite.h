/*! \file */
/*******************************************
 *                                         *
 *  File auto-generated by `::safer_ffi`.  *
 *                                         *
 *  Do not manually edit this file.        *
 *                                         *
 *******************************************/

#ifndef __RUST_MLS_LITE__
#define __RUST_MLS_LITE__
#ifdef __cplusplus
extern "C" {
#endif

/** \brief
 *  Application specific identifier.
 *
 *  A custom application level identifier that can be optionally stored
 *  within the `leaf_node_extensions` of a group [Member](crate::group::Member).
 */
typedef struct ApplicationIdExt ApplicationIdExt_t;

/** <No documentation available> */
ApplicationIdExt_t *
application_id_ext_clone (
    ApplicationIdExt_t const * x);

/** <No documentation available> */
void
application_id_ext_free (
    ApplicationIdExt_t * _x);


#include <stddef.h>
#include <stdint.h>

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_uint8 {
    /** \brief
     *  Pointer to the first element (if any).
     */
    uint8_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_uint8_t;

/** <No documentation available> */
slice_ref_uint8_t
application_id_ext_identifier (
    ApplicationIdExt_t const * __safer_ffi_gen_self);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_uint8 {
    /** <No documentation available> */
    uint8_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_uint8_t;

/** <No documentation available> */
ApplicationIdExt_t *
application_id_ext_new (
    Vec_uint8_t identifier);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_ApplicationIdExt {
    /** \brief
     *  Pointer to the first element (if any).
     */
    ApplicationIdExt_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_ApplicationIdExt_t;

/** <No documentation available> */
ApplicationIdExt_t const *
application_id_ext_slice_get (
    slice_ref_ApplicationIdExt_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_ApplicationIdExt {
    /** \brief
     *  Pointer to the first element (if any).
     */
    ApplicationIdExt_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_ApplicationIdExt_t;

/** <No documentation available> */
ApplicationIdExt_t *
application_id_ext_slice_get_mut (
    slice_mut_ApplicationIdExt_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_ApplicationIdExt {
    /** <No documentation available> */
    ApplicationIdExt_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_ApplicationIdExt_t;

/** <No documentation available> */
slice_ref_ApplicationIdExt_t
application_id_ext_vec_as_slice (
    Vec_ApplicationIdExt_t const * v);

/** <No documentation available> */
slice_mut_ApplicationIdExt_t
application_id_ext_vec_as_slice_mut (
    Vec_ApplicationIdExt_t * v);

/** <No documentation available> */
void
application_id_ext_vec_free (
    Vec_ApplicationIdExt_t _v);

/** <No documentation available> */
Vec_ApplicationIdExt_t
application_id_ext_vec_new (void);

/** <No documentation available> */
void
application_id_ext_vec_push (
    Vec_ApplicationIdExt_t * v,
    ApplicationIdExt_t * item);

/** \brief
 *  Description of a MLS application message.
 */
typedef struct ApplicationMessageDescription ApplicationMessageDescription_t;

/** <No documentation available> */
ApplicationMessageDescription_t *
application_message_description_clone (
    ApplicationMessageDescription_t const * x);

/** <No documentation available> */
slice_ref_uint8_t
application_message_description_data (
    ApplicationMessageDescription_t const * __safer_ffi_gen_self);

/** <No documentation available> */
void
application_message_description_free (
    ApplicationMessageDescription_t * _x);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_ApplicationMessageDescription {
    /** \brief
     *  Pointer to the first element (if any).
     */
    ApplicationMessageDescription_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_ApplicationMessageDescription_t;

/** <No documentation available> */
ApplicationMessageDescription_t const *
application_message_description_slice_get (
    slice_ref_ApplicationMessageDescription_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_ApplicationMessageDescription {
    /** \brief
     *  Pointer to the first element (if any).
     */
    ApplicationMessageDescription_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_ApplicationMessageDescription_t;

/** <No documentation available> */
ApplicationMessageDescription_t *
application_message_description_slice_get_mut (
    slice_mut_ApplicationMessageDescription_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_ApplicationMessageDescription {
    /** <No documentation available> */
    ApplicationMessageDescription_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_ApplicationMessageDescription_t;

/** <No documentation available> */
slice_ref_ApplicationMessageDescription_t
application_message_description_vec_as_slice (
    Vec_ApplicationMessageDescription_t const * v);

/** <No documentation available> */
slice_mut_ApplicationMessageDescription_t
application_message_description_vec_as_slice_mut (
    Vec_ApplicationMessageDescription_t * v);

/** <No documentation available> */
void
application_message_description_vec_free (
    Vec_ApplicationMessageDescription_t _v);

/** <No documentation available> */
Vec_ApplicationMessageDescription_t
application_message_description_vec_new (void);

/** <No documentation available> */
void
application_message_description_vec_push (
    Vec_ApplicationMessageDescription_t * v,
    ApplicationMessageDescription_t * item);

/** \brief
 *  Bare assertion of an identity without any additional information.
 *
 *  The format of the encoded identity is defined by the application.
 *
 *
 *  # Warning
 *
 *  Basic credentials are inherently insecure since they can not be
 *  properly validated. It is not recommended to use [`BasicCredential`]
 *  in production applications.
 */
typedef struct BasicCredential BasicCredential_t;

/** <No documentation available> */
BasicCredential_t *
basic_credential_clone (
    BasicCredential_t const * x);

/** <No documentation available> */
void
basic_credential_free (
    BasicCredential_t * _x);

/** <No documentation available> */
slice_ref_uint8_t
basic_credential_identifier (
    BasicCredential_t const * __safer_ffi_gen_self);

/** <No documentation available> */
BasicCredential_t *
basic_credential_new (
    Vec_uint8_t identifier);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_BasicCredential {
    /** \brief
     *  Pointer to the first element (if any).
     */
    BasicCredential_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_BasicCredential_t;

/** <No documentation available> */
BasicCredential_t const *
basic_credential_slice_get (
    slice_ref_BasicCredential_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_BasicCredential {
    /** \brief
     *  Pointer to the first element (if any).
     */
    BasicCredential_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_BasicCredential_t;

/** <No documentation available> */
BasicCredential_t *
basic_credential_slice_get_mut (
    slice_mut_BasicCredential_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_BasicCredential {
    /** <No documentation available> */
    BasicCredential_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_BasicCredential_t;

/** <No documentation available> */
slice_ref_BasicCredential_t
basic_credential_vec_as_slice (
    Vec_BasicCredential_t const * v);

/** <No documentation available> */
slice_mut_BasicCredential_t
basic_credential_vec_as_slice_mut (
    Vec_BasicCredential_t * v);

/** <No documentation available> */
void
basic_credential_vec_free (
    Vec_BasicCredential_t _v);

/** <No documentation available> */
Vec_BasicCredential_t
basic_credential_vec_new (void);

/** <No documentation available> */
void
basic_credential_vec_push (
    Vec_BasicCredential_t * v,
    BasicCredential_t * item);

/** \brief
 *  Capabilities of a MLS client
 */
typedef struct Capabilities Capabilities_t;

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_uint16 {
    /** \brief
     *  Pointer to the first element (if any).
     */
    uint16_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_uint16_t;

/** <No documentation available> */
slice_ref_uint16_t
capabilities_cipher_suites (
    Capabilities_t const * __safer_ffi_gen_self);

/** <No documentation available> */
Capabilities_t *
capabilities_clone (
    Capabilities_t const * x);

/** <No documentation available> */
slice_ref_uint16_t
capabilities_credentials (
    Capabilities_t const * __safer_ffi_gen_self);

/** <No documentation available> */
slice_ref_uint16_t
capabilities_extensions (
    Capabilities_t const * __safer_ffi_gen_self);

/** <No documentation available> */
void
capabilities_free (
    Capabilities_t * _x);

/** <No documentation available> */
slice_ref_uint16_t
capabilities_proposals (
    Capabilities_t const * __safer_ffi_gen_self);

/** <No documentation available> */
slice_ref_uint16_t
capabilities_protocol_versions (
    Capabilities_t const * __safer_ffi_gen_self);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_Capabilities {
    /** \brief
     *  Pointer to the first element (if any).
     */
    Capabilities_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_Capabilities_t;

/** <No documentation available> */
Capabilities_t const *
capabilities_slice_get (
    slice_ref_Capabilities_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_Capabilities {
    /** \brief
     *  Pointer to the first element (if any).
     */
    Capabilities_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_Capabilities_t;

/** <No documentation available> */
Capabilities_t *
capabilities_slice_get_mut (
    slice_mut_Capabilities_t items,
    size_t index);

/** <No documentation available> */
Capabilities_t *
capabilities_sorted (
    Capabilities_t * __safer_ffi_gen_self);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_Capabilities {
    /** <No documentation available> */
    Capabilities_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_Capabilities_t;

/** <No documentation available> */
slice_ref_Capabilities_t
capabilities_vec_as_slice (
    Vec_Capabilities_t const * v);

/** <No documentation available> */
slice_mut_Capabilities_t
capabilities_vec_as_slice_mut (
    Vec_Capabilities_t * v);

/** <No documentation available> */
void
capabilities_vec_free (
    Vec_Capabilities_t _v);

/** <No documentation available> */
Vec_Capabilities_t
capabilities_vec_new (void);

/** <No documentation available> */
void
capabilities_vec_push (
    Vec_Capabilities_t * v,
    Capabilities_t * item);

/** \brief
 *  A chain of [`DerCertificate`] that is ordered from leaf to root.
 *
 *  Certificate chains MAY leave out root CA's so long as they are
 *  provided as input to whatever certificate validator ultimately is
 *  verifying the chain.
 */
typedef struct CertificateChain CertificateChain_t;

/** <No documentation available> */
CertificateChain_t *
certificate_chain_clone (
    CertificateChain_t const * x);

/** <No documentation available> */
void
certificate_chain_free (
    CertificateChain_t * _x);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_CertificateChain {
    /** \brief
     *  Pointer to the first element (if any).
     */
    CertificateChain_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_CertificateChain_t;

/** <No documentation available> */
CertificateChain_t const *
certificate_chain_slice_get (
    slice_ref_CertificateChain_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_CertificateChain {
    /** \brief
     *  Pointer to the first element (if any).
     */
    CertificateChain_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_CertificateChain_t;

/** <No documentation available> */
CertificateChain_t *
certificate_chain_slice_get_mut (
    slice_mut_CertificateChain_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_CertificateChain {
    /** <No documentation available> */
    CertificateChain_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_CertificateChain_t;

/** <No documentation available> */
slice_ref_CertificateChain_t
certificate_chain_vec_as_slice (
    Vec_CertificateChain_t const * v);

/** <No documentation available> */
slice_mut_CertificateChain_t
certificate_chain_vec_as_slice_mut (
    Vec_CertificateChain_t * v);

/** <No documentation available> */
void
certificate_chain_vec_free (
    Vec_CertificateChain_t _v);

/** <No documentation available> */
Vec_CertificateChain_t
certificate_chain_vec_new (void);

/** <No documentation available> */
void
certificate_chain_vec_push (
    Vec_CertificateChain_t * v,
    CertificateChain_t * item);

/** <No documentation available> */
void
cipher_suite_free (
    uint16_t _x);

/** \brief
 *  Description of a processed MLS commit message.
 */
typedef struct CommitMessageDescription CommitMessageDescription_t;

/** <No documentation available> */
CommitMessageDescription_t *
commit_message_description_clone (
    CommitMessageDescription_t const * x);

/** <No documentation available> */
void
commit_message_description_free (
    CommitMessageDescription_t * _x);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_CommitMessageDescription {
    /** \brief
     *  Pointer to the first element (if any).
     */
    CommitMessageDescription_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_CommitMessageDescription_t;

/** <No documentation available> */
CommitMessageDescription_t const *
commit_message_description_slice_get (
    slice_ref_CommitMessageDescription_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_CommitMessageDescription {
    /** \brief
     *  Pointer to the first element (if any).
     */
    CommitMessageDescription_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_CommitMessageDescription_t;

/** <No documentation available> */
CommitMessageDescription_t *
commit_message_description_slice_get_mut (
    slice_mut_CommitMessageDescription_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_CommitMessageDescription {
    /** <No documentation available> */
    CommitMessageDescription_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_CommitMessageDescription_t;

/** <No documentation available> */
slice_ref_CommitMessageDescription_t
commit_message_description_vec_as_slice (
    Vec_CommitMessageDescription_t const * v);

/** <No documentation available> */
slice_mut_CommitMessageDescription_t
commit_message_description_vec_as_slice_mut (
    Vec_CommitMessageDescription_t * v);

/** <No documentation available> */
void
commit_message_description_vec_free (
    Vec_CommitMessageDescription_t _v);

/** <No documentation available> */
Vec_CommitMessageDescription_t
commit_message_description_vec_new (void);

/** <No documentation available> */
void
commit_message_description_vec_push (
    Vec_CommitMessageDescription_t * v,
    CommitMessageDescription_t * item);

/** \brief
 *  Result of MLS commit operation using
 *  [`Group::commit`](crate::group::Group::commit) or
 *  [`CommitBuilder::build`](CommitBuilder::build).
 */
typedef struct CommitOutput CommitOutput_t;

/** <No documentation available> */
CommitOutput_t *
commit_output_clone (
    CommitOutput_t const * x);

/** \brief
 *  A MLS protocol message for sending data over the wire.
 */
typedef struct MlsMessage MlsMessage_t;

/** <No documentation available> */
MlsMessage_t const *
commit_output_commit_message (
    CommitOutput_t const * __safer_ffi_gen_self);

/** <No documentation available> */
MlsMessage_t const *
commit_output_external_commit_group_info (
    CommitOutput_t const * __safer_ffi_gen_self);

/** <No documentation available> */
void
commit_output_free (
    CommitOutput_t * _x);

/** <No documentation available> */
typedef struct ExportedTree ExportedTree_t;

/** <No documentation available> */
ExportedTree_t const *
commit_output_ratchet_tree (
    CommitOutput_t const * __safer_ffi_gen_self);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_CommitOutput {
    /** \brief
     *  Pointer to the first element (if any).
     */
    CommitOutput_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_CommitOutput_t;

/** <No documentation available> */
CommitOutput_t const *
commit_output_slice_get (
    slice_ref_CommitOutput_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_CommitOutput {
    /** \brief
     *  Pointer to the first element (if any).
     */
    CommitOutput_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_CommitOutput_t;

/** <No documentation available> */
CommitOutput_t *
commit_output_slice_get_mut (
    slice_mut_CommitOutput_t items,
    size_t index);

/** \brief
 *  Proposal description used as input to a
 *  [`MlsRules`](crate::MlsRules).
 */
typedef struct ProposalInfo_Proposal ProposalInfo_Proposal_t;

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_ProposalInfo_Proposal {
    /** \brief
     *  Pointer to the first element (if any).
     */
    ProposalInfo_Proposal_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_ProposalInfo_Proposal_t;

/** <No documentation available> */
slice_ref_ProposalInfo_Proposal_t
commit_output_unused_proposals (
    CommitOutput_t const * __safer_ffi_gen_self);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_CommitOutput {
    /** <No documentation available> */
    CommitOutput_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_CommitOutput_t;

/** <No documentation available> */
slice_ref_CommitOutput_t
commit_output_vec_as_slice (
    Vec_CommitOutput_t const * v);

/** <No documentation available> */
slice_mut_CommitOutput_t
commit_output_vec_as_slice_mut (
    Vec_CommitOutput_t * v);

/** <No documentation available> */
void
commit_output_vec_free (
    Vec_CommitOutput_t _v);

/** <No documentation available> */
Vec_CommitOutput_t
commit_output_vec_new (void);

/** <No documentation available> */
void
commit_output_vec_push (
    Vec_CommitOutput_t * v,
    CommitOutput_t * item);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_MlsMessage {
    /** \brief
     *  Pointer to the first element (if any).
     */
    MlsMessage_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_MlsMessage_t;

/** <No documentation available> */
slice_ref_MlsMessage_t
commit_output_welcome_messages (
    CommitOutput_t const * __safer_ffi_gen_self);

/** \brief
 *  The layout of mls_rs_core::identity::credential::Credential is subject to change
 */
typedef struct Credential Credential_t;

/** <No documentation available> */
Credential_t *
credential_clone (
    Credential_t const * x);

/** <No documentation available> */
/** \remark Has the same ABI as `int32_t` **/
#ifdef DOXYGEN
typedef
#endif
enum CredentialDiscriminant {
    /** <No documentation available> */
    CREDENTIAL_DISCRIMINANT_BASIC,
    /** <No documentation available> */
    CREDENTIAL_DISCRIMINANT_X509,
    /** <No documentation available> */
    CREDENTIAL_DISCRIMINANT_CUSTOM,
}
#ifndef DOXYGEN
; typedef int32_t
#endif
CredentialDiscriminant_t;

/** <No documentation available> */
CredentialDiscriminant_t
credential_discriminant (
    Credential_t const * x);

/** <No documentation available> */
void
credential_free (
    Credential_t * _x);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_Credential {
    /** \brief
     *  Pointer to the first element (if any).
     */
    Credential_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_Credential_t;

/** <No documentation available> */
Credential_t const *
credential_slice_get (
    slice_ref_Credential_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_Credential {
    /** \brief
     *  Pointer to the first element (if any).
     */
    Credential_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_Credential_t;

/** <No documentation available> */
Credential_t *
credential_slice_get_mut (
    slice_mut_Credential_t items,
    size_t index);

/** <No documentation available> */
BasicCredential_t const *
credential_to_basic (
    Credential_t const * x);

/** \brief
 *  Custom user created credential type.
 *
 *  # Warning
 *
 *  In order to use a custom credential within an MLS group, a supporting
 *  [`IdentityProvider`](crate::identity::IdentityProvider) must be created that can
 *  authenticate the credential.
 */
typedef struct CustomCredential CustomCredential_t;

/** <No documentation available> */
CustomCredential_t const *
credential_to_custom (
    Credential_t const * x);

/** <No documentation available> */
CertificateChain_t const *
credential_to_x509 (
    Credential_t const * x);

/** <No documentation available> */
void
credential_type_free (
    uint16_t _x);

/** <No documentation available> */
uint16_t
credential_type_new (
    uint16_t raw_value);

/** <No documentation available> */
uint16_t
credential_type_raw_value (
    uint16_t const * __safer_ffi_gen_self);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_Credential {
    /** <No documentation available> */
    Credential_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_Credential_t;

/** <No documentation available> */
slice_ref_Credential_t
credential_vec_as_slice (
    Vec_Credential_t const * v);

/** <No documentation available> */
slice_mut_Credential_t
credential_vec_as_slice_mut (
    Vec_Credential_t * v);

/** <No documentation available> */
void
credential_vec_free (
    Vec_Credential_t _v);

/** <No documentation available> */
Vec_Credential_t
credential_vec_new (void);

/** <No documentation available> */
void
credential_vec_push (
    Vec_Credential_t * v,
    Credential_t * item);

/** <No documentation available> */
CustomCredential_t *
custom_credential_clone (
    CustomCredential_t const * x);

/** <No documentation available> */
uint16_t
custom_credential_credential_type (
    CustomCredential_t const * __safer_ffi_gen_self);

/** <No documentation available> */
slice_ref_uint8_t
custom_credential_data (
    CustomCredential_t const * __safer_ffi_gen_self);

/** <No documentation available> */
void
custom_credential_free (
    CustomCredential_t * _x);

/** <No documentation available> */
CustomCredential_t *
custom_credential_new (
    uint16_t credential_type,
    Vec_uint8_t data);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_CustomCredential {
    /** \brief
     *  Pointer to the first element (if any).
     */
    CustomCredential_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_CustomCredential_t;

/** <No documentation available> */
CustomCredential_t const *
custom_credential_slice_get (
    slice_ref_CustomCredential_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_CustomCredential {
    /** \brief
     *  Pointer to the first element (if any).
     */
    CustomCredential_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_CustomCredential_t;

/** <No documentation available> */
CustomCredential_t *
custom_credential_slice_get_mut (
    slice_mut_CustomCredential_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_CustomCredential {
    /** <No documentation available> */
    CustomCredential_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_CustomCredential_t;

/** <No documentation available> */
slice_ref_CustomCredential_t
custom_credential_vec_as_slice (
    Vec_CustomCredential_t const * v);

/** <No documentation available> */
slice_mut_CustomCredential_t
custom_credential_vec_as_slice_mut (
    Vec_CustomCredential_t * v);

/** <No documentation available> */
void
custom_credential_vec_free (
    Vec_CustomCredential_t _v);

/** <No documentation available> */
Vec_CustomCredential_t
custom_credential_vec_new (void);

/** <No documentation available> */
void
custom_credential_vec_push (
    Vec_CustomCredential_t * v,
    CustomCredential_t * item);

/** \brief
 *  A user defined custom proposal.
 *
 *  User defined proposals are passed through the protocol as an opaque value.
 */
typedef struct CustomProposal CustomProposal_t;

/** <No documentation available> */
CustomProposal_t *
custom_proposal_clone (
    CustomProposal_t const * x);

/** <No documentation available> */
slice_ref_uint8_t
custom_proposal_data (
    CustomProposal_t const * __safer_ffi_gen_self);

/** <No documentation available> */
void
custom_proposal_free (
    CustomProposal_t * _x);

/** <No documentation available> */
CustomProposal_t *
custom_proposal_new (
    uint16_t proposal_type,
    Vec_uint8_t data);

/** <No documentation available> */
uint16_t
custom_proposal_proposal_type (
    CustomProposal_t const * __safer_ffi_gen_self);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_CustomProposal {
    /** \brief
     *  Pointer to the first element (if any).
     */
    CustomProposal_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_CustomProposal_t;

/** <No documentation available> */
CustomProposal_t const *
custom_proposal_slice_get (
    slice_ref_CustomProposal_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_CustomProposal {
    /** \brief
     *  Pointer to the first element (if any).
     */
    CustomProposal_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_CustomProposal_t;

/** <No documentation available> */
CustomProposal_t *
custom_proposal_slice_get_mut (
    slice_mut_CustomProposal_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_CustomProposal {
    /** <No documentation available> */
    CustomProposal_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_CustomProposal_t;

/** <No documentation available> */
slice_ref_CustomProposal_t
custom_proposal_vec_as_slice (
    Vec_CustomProposal_t const * v);

/** <No documentation available> */
slice_mut_CustomProposal_t
custom_proposal_vec_as_slice_mut (
    Vec_CustomProposal_t * v);

/** <No documentation available> */
void
custom_proposal_vec_free (
    Vec_CustomProposal_t _v);

/** <No documentation available> */
Vec_CustomProposal_t
custom_proposal_vec_new (void);

/** <No documentation available> */
void
custom_proposal_vec_push (
    Vec_CustomProposal_t * v,
    CustomProposal_t * item);

/** \brief
 *  X.509 certificate in DER format.
 */
typedef struct DerCertificate DerCertificate_t;

/** <No documentation available> */
DerCertificate_t *
der_certificate_clone (
    DerCertificate_t const * x);

/** <No documentation available> */
void
der_certificate_free (
    DerCertificate_t * _x);

/** <No documentation available> */
Vec_uint8_t
der_certificate_into_vec (
    DerCertificate_t * __safer_ffi_gen_self);

/** <No documentation available> */
DerCertificate_t *
der_certificate_new (
    Vec_uint8_t data);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_DerCertificate {
    /** \brief
     *  Pointer to the first element (if any).
     */
    DerCertificate_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_DerCertificate_t;

/** <No documentation available> */
DerCertificate_t const *
der_certificate_slice_get (
    slice_ref_DerCertificate_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_DerCertificate {
    /** \brief
     *  Pointer to the first element (if any).
     */
    DerCertificate_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_DerCertificate_t;

/** <No documentation available> */
DerCertificate_t *
der_certificate_slice_get_mut (
    slice_mut_DerCertificate_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_DerCertificate {
    /** <No documentation available> */
    DerCertificate_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_DerCertificate_t;

/** <No documentation available> */
slice_ref_DerCertificate_t
der_certificate_vec_as_slice (
    Vec_DerCertificate_t const * v);

/** <No documentation available> */
slice_mut_DerCertificate_t
der_certificate_vec_as_slice_mut (
    Vec_DerCertificate_t * v);

/** <No documentation available> */
void
der_certificate_vec_free (
    Vec_DerCertificate_t _v);

/** <No documentation available> */
Vec_DerCertificate_t
der_certificate_vec_new (void);

/** <No documentation available> */
void
der_certificate_vec_push (
    Vec_DerCertificate_t * v,
    DerCertificate_t * item);

/** <No documentation available> */
size_t
exported_tree_byte_size (
    ExportedTree_t const * __safer_ffi_gen_self);

/** <No documentation available> */
ExportedTree_t *
exported_tree_clone (
    ExportedTree_t const * x);

/** <No documentation available> */
void
exported_tree_free (
    ExportedTree_t * _x);

/** <No documentation available> */
int32_t
exported_tree_from_bytes (
    slice_ref_uint8_t bytes,
    ExportedTree_t * * __safer_ffi_gen_out);

/** <No documentation available> */
ExportedTree_t *
exported_tree_into_owned (
    ExportedTree_t * __safer_ffi_gen_self);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_ExportedTree {
    /** \brief
     *  Pointer to the first element (if any).
     */
    ExportedTree_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_ExportedTree_t;

/** <No documentation available> */
ExportedTree_t const *
exported_tree_slice_get (
    slice_ref_ExportedTree_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_ExportedTree {
    /** \brief
     *  Pointer to the first element (if any).
     */
    ExportedTree_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_ExportedTree_t;

/** <No documentation available> */
ExportedTree_t *
exported_tree_slice_get_mut (
    slice_mut_ExportedTree_t items,
    size_t index);

/** <No documentation available> */
int32_t
exported_tree_to_bytes (
    ExportedTree_t const * __safer_ffi_gen_self,
    Vec_uint8_t * __safer_ffi_gen_out);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_ExportedTree {
    /** <No documentation available> */
    ExportedTree_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_ExportedTree_t;

/** <No documentation available> */
slice_ref_ExportedTree_t
exported_tree_vec_as_slice (
    Vec_ExportedTree_t const * v);

/** <No documentation available> */
slice_mut_ExportedTree_t
exported_tree_vec_as_slice_mut (
    Vec_ExportedTree_t * v);

/** <No documentation available> */
void
exported_tree_vec_free (
    Vec_ExportedTree_t _v);

/** <No documentation available> */
Vec_ExportedTree_t
exported_tree_vec_new (void);

/** <No documentation available> */
void
exported_tree_vec_push (
    Vec_ExportedTree_t * v,
    ExportedTree_t * item);

/** \brief
 *  An MLS protocol [extension](https://messaginglayersecurity.rocks/mls-protocol/draft-ietf-mls-protocol.html#name-extensions).
 *
 *  Extensions are used as customization points in various parts of the
 *  MLS protocol and are inserted into an [ExtensionList](self::ExtensionList).
 */
typedef struct Extension Extension_t;

/** <No documentation available> */
Extension_t *
extension_clone (
    Extension_t const * x);

/** <No documentation available> */
slice_ref_uint8_t
extension_extension_data (
    Extension_t const * __safer_ffi_gen_self);

/** <No documentation available> */
uint16_t
extension_extension_type (
    Extension_t const * __safer_ffi_gen_self);

/** <No documentation available> */
void
extension_free (
    Extension_t * _x);

/** \brief
 *  A collection of MLS [Extensions](super::Extension).
 *
 *
 *  # Warning
 *
 *  Extension lists require that each type of extension has at most one entry.
 */
typedef struct ExtensionList ExtensionList_t;

/** <No documentation available> */
ExtensionList_t *
extension_list_clone (
    ExtensionList_t const * x);

/** <No documentation available> */
void
extension_list_free (
    ExtensionList_t * _x);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_ExtensionList {
    /** \brief
     *  Pointer to the first element (if any).
     */
    ExtensionList_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_ExtensionList_t;

/** <No documentation available> */
ExtensionList_t const *
extension_list_slice_get (
    slice_ref_ExtensionList_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_ExtensionList {
    /** \brief
     *  Pointer to the first element (if any).
     */
    ExtensionList_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_ExtensionList_t;

/** <No documentation available> */
ExtensionList_t *
extension_list_slice_get_mut (
    slice_mut_ExtensionList_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_ExtensionList {
    /** <No documentation available> */
    ExtensionList_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_ExtensionList_t;

/** <No documentation available> */
slice_ref_ExtensionList_t
extension_list_vec_as_slice (
    Vec_ExtensionList_t const * v);

/** <No documentation available> */
slice_mut_ExtensionList_t
extension_list_vec_as_slice_mut (
    Vec_ExtensionList_t * v);

/** <No documentation available> */
void
extension_list_vec_free (
    Vec_ExtensionList_t _v);

/** <No documentation available> */
Vec_ExtensionList_t
extension_list_vec_new (void);

/** <No documentation available> */
void
extension_list_vec_push (
    Vec_ExtensionList_t * v,
    ExtensionList_t * item);

/** <No documentation available> */
Extension_t *
extension_new (
    uint16_t extension_type,
    Vec_uint8_t extension_data);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_Extension {
    /** \brief
     *  Pointer to the first element (if any).
     */
    Extension_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_Extension_t;

/** <No documentation available> */
Extension_t const *
extension_slice_get (
    slice_ref_Extension_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_Extension {
    /** \brief
     *  Pointer to the first element (if any).
     */
    Extension_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_Extension_t;

/** <No documentation available> */
Extension_t *
extension_slice_get_mut (
    slice_mut_Extension_t items,
    size_t index);

/** <No documentation available> */
void
extension_type_free (
    uint16_t _x);


#include <stdbool.h>

/** <No documentation available> */
bool
extension_type_is_default (
    uint16_t const * __safer_ffi_gen_self);

/** <No documentation available> */
uint16_t
extension_type_new (
    uint16_t raw_value);

/** <No documentation available> */
uint16_t
extension_type_raw_value (
    uint16_t const * __safer_ffi_gen_self);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_Extension {
    /** <No documentation available> */
    Extension_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_Extension_t;

/** <No documentation available> */
slice_ref_Extension_t
extension_vec_as_slice (
    Vec_Extension_t const * v);

/** <No documentation available> */
slice_mut_Extension_t
extension_vec_as_slice_mut (
    Vec_Extension_t * v);

/** <No documentation available> */
void
extension_vec_free (
    Vec_Extension_t _v);

/** <No documentation available> */
Vec_Extension_t
extension_vec_new (void);

/** <No documentation available> */
void
extension_vec_push (
    Vec_Extension_t * v,
    Extension_t * item);

/** \brief
 *  An external pre-shared key identifier.
 */
typedef struct ExternalPskId ExternalPskId_t;

/** <No documentation available> */
ExternalPskId_t *
external_psk_id_clone (
    ExternalPskId_t const * x);

/** <No documentation available> */
void
external_psk_id_free (
    ExternalPskId_t * _x);

/** <No documentation available> */
ExternalPskId_t *
external_psk_id_new (
    Vec_uint8_t id_data);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_ExternalPskId {
    /** \brief
     *  Pointer to the first element (if any).
     */
    ExternalPskId_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_ExternalPskId_t;

/** <No documentation available> */
ExternalPskId_t const *
external_psk_id_slice_get (
    slice_ref_ExternalPskId_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_ExternalPskId {
    /** \brief
     *  Pointer to the first element (if any).
     */
    ExternalPskId_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_ExternalPskId_t;

/** <No documentation available> */
ExternalPskId_t *
external_psk_id_slice_get_mut (
    slice_mut_ExternalPskId_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_ExternalPskId {
    /** <No documentation available> */
    ExternalPskId_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_ExternalPskId_t;

/** <No documentation available> */
slice_ref_ExternalPskId_t
external_psk_id_vec_as_slice (
    Vec_ExternalPskId_t const * v);

/** <No documentation available> */
slice_mut_ExternalPskId_t
external_psk_id_vec_as_slice_mut (
    Vec_ExternalPskId_t * v);

/** <No documentation available> */
void
external_psk_id_vec_free (
    Vec_ExternalPskId_t _v);

/** <No documentation available> */
Vec_ExternalPskId_t
external_psk_id_vec_new (void);

/** <No documentation available> */
void
external_psk_id_vec_push (
    Vec_ExternalPskId_t * v,
    ExternalPskId_t * item);

/** \brief
 *  External public key used for [External Commits](crate::Client::commit_external).
 *
 *  This proposal type is optionally provided as part of a
 *  [Group Info](crate::group::Group::group_info_message).
 */
typedef struct ExternalPubExt ExternalPubExt_t;

/** <No documentation available> */
ExternalPubExt_t *
external_pub_ext_clone (
    ExternalPubExt_t const * x);

/** \brief
 *  Byte representation of an HPKE public key. For ciphersuites using elliptic curves,
 *  the public key should be represented in the uncompressed format.
 */
typedef struct HpkePublicKey HpkePublicKey_t;

/** <No documentation available> */
HpkePublicKey_t const *
external_pub_ext_external_pub (
    ExternalPubExt_t const * __safer_ffi_gen_self);

/** <No documentation available> */
void
external_pub_ext_free (
    ExternalPubExt_t * _x);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_ExternalPubExt {
    /** \brief
     *  Pointer to the first element (if any).
     */
    ExternalPubExt_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_ExternalPubExt_t;

/** <No documentation available> */
ExternalPubExt_t const *
external_pub_ext_slice_get (
    slice_ref_ExternalPubExt_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_ExternalPubExt {
    /** \brief
     *  Pointer to the first element (if any).
     */
    ExternalPubExt_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_ExternalPubExt_t;

/** <No documentation available> */
ExternalPubExt_t *
external_pub_ext_slice_get_mut (
    slice_mut_ExternalPubExt_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_ExternalPubExt {
    /** <No documentation available> */
    ExternalPubExt_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_ExternalPubExt_t;

/** <No documentation available> */
slice_ref_ExternalPubExt_t
external_pub_ext_vec_as_slice (
    Vec_ExternalPubExt_t const * v);

/** <No documentation available> */
slice_mut_ExternalPubExt_t
external_pub_ext_vec_as_slice_mut (
    Vec_ExternalPubExt_t * v);

/** <No documentation available> */
void
external_pub_ext_vec_free (
    Vec_ExternalPubExt_t _v);

/** <No documentation available> */
Vec_ExternalPubExt_t
external_pub_ext_vec_new (void);

/** <No documentation available> */
void
external_pub_ext_vec_push (
    Vec_ExternalPubExt_t * v,
    ExternalPubExt_t * item);

/** \brief
 *  Enable proposals by an [ExternalClient](crate::external_client::ExternalClient).
 */
typedef struct ExternalSendersExt ExternalSendersExt_t;

/** \brief
 *  MLS group member identity represented as a combination of a
 *  public [`SignaturePublicKey`] and [`Credential`].
 */
typedef struct SigningIdentity SigningIdentity_t;

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_SigningIdentity {
    /** \brief
     *  Pointer to the first element (if any).
     */
    SigningIdentity_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_SigningIdentity_t;

/** <No documentation available> */
slice_ref_SigningIdentity_t
external_senders_ext_allowed_senders (
    ExternalSendersExt_t const * __safer_ffi_gen_self);

/** <No documentation available> */
ExternalSendersExt_t *
external_senders_ext_clone (
    ExternalSendersExt_t const * x);

/** <No documentation available> */
void
external_senders_ext_free (
    ExternalSendersExt_t * _x);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_SigningIdentity {
    /** <No documentation available> */
    SigningIdentity_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_SigningIdentity_t;

/** <No documentation available> */
ExternalSendersExt_t *
external_senders_ext_new (
    Vec_SigningIdentity_t allowed_senders);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_ExternalSendersExt {
    /** \brief
     *  Pointer to the first element (if any).
     */
    ExternalSendersExt_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_ExternalSendersExt_t;

/** <No documentation available> */
ExternalSendersExt_t const *
external_senders_ext_slice_get (
    slice_ref_ExternalSendersExt_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_ExternalSendersExt {
    /** \brief
     *  Pointer to the first element (if any).
     */
    ExternalSendersExt_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_ExternalSendersExt_t;

/** <No documentation available> */
ExternalSendersExt_t *
external_senders_ext_slice_get_mut (
    slice_mut_ExternalSendersExt_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_ExternalSendersExt {
    /** <No documentation available> */
    ExternalSendersExt_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_ExternalSendersExt_t;

/** <No documentation available> */
slice_ref_ExternalSendersExt_t
external_senders_ext_vec_as_slice (
    Vec_ExternalSendersExt_t const * v);

/** <No documentation available> */
slice_mut_ExternalSendersExt_t
external_senders_ext_vec_as_slice_mut (
    Vec_ExternalSendersExt_t * v);

/** <No documentation available> */
void
external_senders_ext_vec_free (
    Vec_ExternalSendersExt_t _v);

/** <No documentation available> */
Vec_ExternalSendersExt_t
external_senders_ext_vec_new (void);

/** <No documentation available> */
void
external_senders_ext_vec_push (
    Vec_ExternalSendersExt_t * v,
    ExternalSendersExt_t * item);

/** <No documentation available> */
typedef struct GroupConfig GroupConfig_t;

/** <No documentation available> */
void
group_config_free (
    GroupConfig_t * _x);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_GroupConfig {
    /** \brief
     *  Pointer to the first element (if any).
     */
    GroupConfig_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_GroupConfig_t;

/** <No documentation available> */
GroupConfig_t const *
group_config_slice_get (
    slice_ref_GroupConfig_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_GroupConfig {
    /** \brief
     *  Pointer to the first element (if any).
     */
    GroupConfig_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_GroupConfig_t;

/** <No documentation available> */
GroupConfig_t *
group_config_slice_get_mut (
    slice_mut_GroupConfig_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_GroupConfig {
    /** <No documentation available> */
    GroupConfig_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_GroupConfig_t;

/** <No documentation available> */
slice_ref_GroupConfig_t
group_config_vec_as_slice (
    Vec_GroupConfig_t const * v);

/** <No documentation available> */
slice_mut_GroupConfig_t
group_config_vec_as_slice_mut (
    Vec_GroupConfig_t * v);

/** <No documentation available> */
void
group_config_vec_free (
    Vec_GroupConfig_t _v);

/** <No documentation available> */
Vec_GroupConfig_t
group_config_vec_new (void);

/** <No documentation available> */
void
group_config_vec_push (
    Vec_GroupConfig_t * v,
    GroupConfig_t * item);

/** <No documentation available> */
typedef struct GroupContext GroupContext_t;

/** <No documentation available> */
uint16_t
group_context_cipher_suite (
    GroupContext_t const * __safer_ffi_gen_self);

/** <No documentation available> */
GroupContext_t *
group_context_clone (
    GroupContext_t const * x);

/** <No documentation available> */
uint64_t
group_context_epoch (
    GroupContext_t const * __safer_ffi_gen_self);

/** <No documentation available> */
ExtensionList_t const *
group_context_extensions (
    GroupContext_t const * __safer_ffi_gen_self);

/** <No documentation available> */
typedef struct GroupContextExtensions GroupContextExtensions_t;

/** <No documentation available> */
void
group_context_extensions_free (
    GroupContextExtensions_t * _x);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_GroupContextExtensions {
    /** \brief
     *  Pointer to the first element (if any).
     */
    GroupContextExtensions_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_GroupContextExtensions_t;

/** <No documentation available> */
GroupContextExtensions_t const *
group_context_extensions_slice_get (
    slice_ref_GroupContextExtensions_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_GroupContextExtensions {
    /** \brief
     *  Pointer to the first element (if any).
     */
    GroupContextExtensions_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_GroupContextExtensions_t;

/** <No documentation available> */
GroupContextExtensions_t *
group_context_extensions_slice_get_mut (
    slice_mut_GroupContextExtensions_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_GroupContextExtensions {
    /** <No documentation available> */
    GroupContextExtensions_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_GroupContextExtensions_t;

/** <No documentation available> */
slice_ref_GroupContextExtensions_t
group_context_extensions_vec_as_slice (
    Vec_GroupContextExtensions_t const * v);

/** <No documentation available> */
slice_mut_GroupContextExtensions_t
group_context_extensions_vec_as_slice_mut (
    Vec_GroupContextExtensions_t * v);

/** <No documentation available> */
void
group_context_extensions_vec_free (
    Vec_GroupContextExtensions_t _v);

/** <No documentation available> */
Vec_GroupContextExtensions_t
group_context_extensions_vec_new (void);

/** <No documentation available> */
void
group_context_extensions_vec_push (
    Vec_GroupContextExtensions_t * v,
    GroupContextExtensions_t * item);

/** <No documentation available> */
void
group_context_free (
    GroupContext_t * _x);

/** <No documentation available> */
slice_ref_uint8_t
group_context_group_id (
    GroupContext_t const * __safer_ffi_gen_self);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_GroupContext {
    /** \brief
     *  Pointer to the first element (if any).
     */
    GroupContext_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_GroupContext_t;

/** <No documentation available> */
GroupContext_t const *
group_context_slice_get (
    slice_ref_GroupContext_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_GroupContext {
    /** \brief
     *  Pointer to the first element (if any).
     */
    GroupContext_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_GroupContext_t;

/** <No documentation available> */
GroupContext_t *
group_context_slice_get_mut (
    slice_mut_GroupContext_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_GroupContext {
    /** <No documentation available> */
    GroupContext_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_GroupContext_t;

/** <No documentation available> */
slice_ref_GroupContext_t
group_context_vec_as_slice (
    Vec_GroupContext_t const * v);

/** <No documentation available> */
slice_mut_GroupContext_t
group_context_vec_as_slice_mut (
    Vec_GroupContext_t * v);

/** <No documentation available> */
void
group_context_vec_free (
    Vec_GroupContext_t _v);

/** <No documentation available> */
Vec_GroupContext_t
group_context_vec_new (void);

/** <No documentation available> */
void
group_context_vec_push (
    Vec_GroupContext_t * v,
    GroupContext_t * item);

/** <No documentation available> */
uint16_t
group_context_version (
    GroupContext_t const * __safer_ffi_gen_self);

/** <No documentation available> */
typedef struct GroupInfo GroupInfo_t;

/** <No documentation available> */
GroupInfo_t *
group_info_clone (
    GroupInfo_t const * x);

/** <No documentation available> */
ExtensionList_t const *
group_info_extensions (
    GroupInfo_t const * __safer_ffi_gen_self);

/** <No documentation available> */
void
group_info_free (
    GroupInfo_t * _x);

/** <No documentation available> */
GroupContext_t const *
group_info_group_context (
    GroupInfo_t const * __safer_ffi_gen_self);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_GroupInfo {
    /** \brief
     *  Pointer to the first element (if any).
     */
    GroupInfo_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_GroupInfo_t;

/** <No documentation available> */
GroupInfo_t const *
group_info_slice_get (
    slice_ref_GroupInfo_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_GroupInfo {
    /** \brief
     *  Pointer to the first element (if any).
     */
    GroupInfo_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_GroupInfo_t;

/** <No documentation available> */
GroupInfo_t *
group_info_slice_get_mut (
    slice_mut_GroupInfo_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_GroupInfo {
    /** <No documentation available> */
    GroupInfo_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_GroupInfo_t;

/** <No documentation available> */
slice_ref_GroupInfo_t
group_info_vec_as_slice (
    Vec_GroupInfo_t const * v);

/** <No documentation available> */
slice_mut_GroupInfo_t
group_info_vec_as_slice_mut (
    Vec_GroupInfo_t * v);

/** <No documentation available> */
void
group_info_vec_free (
    Vec_GroupInfo_t _v);

/** <No documentation available> */
Vec_GroupInfo_t
group_info_vec_new (void);

/** <No documentation available> */
void
group_info_vec_push (
    Vec_GroupInfo_t * v,
    GroupInfo_t * item);

/** <No documentation available> */
HpkePublicKey_t *
hpke_public_key_clone (
    HpkePublicKey_t const * x);

/** <No documentation available> */
void
hpke_public_key_free (
    HpkePublicKey_t * _x);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_HpkePublicKey {
    /** \brief
     *  Pointer to the first element (if any).
     */
    HpkePublicKey_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_HpkePublicKey_t;

/** <No documentation available> */
HpkePublicKey_t const *
hpke_public_key_slice_get (
    slice_ref_HpkePublicKey_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_HpkePublicKey {
    /** \brief
     *  Pointer to the first element (if any).
     */
    HpkePublicKey_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_HpkePublicKey_t;

/** <No documentation available> */
HpkePublicKey_t *
hpke_public_key_slice_get_mut (
    slice_mut_HpkePublicKey_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_HpkePublicKey {
    /** <No documentation available> */
    HpkePublicKey_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_HpkePublicKey_t;

/** <No documentation available> */
slice_ref_HpkePublicKey_t
hpke_public_key_vec_as_slice (
    Vec_HpkePublicKey_t const * v);

/** <No documentation available> */
slice_mut_HpkePublicKey_t
hpke_public_key_vec_as_slice_mut (
    Vec_HpkePublicKey_t * v);

/** <No documentation available> */
void
hpke_public_key_vec_free (
    Vec_HpkePublicKey_t _v);

/** <No documentation available> */
Vec_HpkePublicKey_t
hpke_public_key_vec_new (void);

/** <No documentation available> */
void
hpke_public_key_vec_push (
    Vec_HpkePublicKey_t * v,
    HpkePublicKey_t * item);

/** \brief
 *  Byte representation of an HPKE secret key.
 */
typedef struct HpkeSecretKey HpkeSecretKey_t;

/** <No documentation available> */
HpkeSecretKey_t *
hpke_secret_key_clone (
    HpkeSecretKey_t const * x);

/** <No documentation available> */
void
hpke_secret_key_free (
    HpkeSecretKey_t * _x);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_HpkeSecretKey {
    /** \brief
     *  Pointer to the first element (if any).
     */
    HpkeSecretKey_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_HpkeSecretKey_t;

/** <No documentation available> */
HpkeSecretKey_t const *
hpke_secret_key_slice_get (
    slice_ref_HpkeSecretKey_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_HpkeSecretKey {
    /** \brief
     *  Pointer to the first element (if any).
     */
    HpkeSecretKey_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_HpkeSecretKey_t;

/** <No documentation available> */
HpkeSecretKey_t *
hpke_secret_key_slice_get_mut (
    slice_mut_HpkeSecretKey_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_HpkeSecretKey {
    /** <No documentation available> */
    HpkeSecretKey_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_HpkeSecretKey_t;

/** <No documentation available> */
slice_ref_HpkeSecretKey_t
hpke_secret_key_vec_as_slice (
    Vec_HpkeSecretKey_t const * v);

/** <No documentation available> */
slice_mut_HpkeSecretKey_t
hpke_secret_key_vec_as_slice_mut (
    Vec_HpkeSecretKey_t * v);

/** <No documentation available> */
void
hpke_secret_key_vec_free (
    Vec_HpkeSecretKey_t _v);

/** <No documentation available> */
Vec_HpkeSecretKey_t
hpke_secret_key_vec_new (void);

/** <No documentation available> */
void
hpke_secret_key_vec_push (
    Vec_HpkeSecretKey_t * v,
    HpkeSecretKey_t * item);

/** <No documentation available> */
typedef struct KeyPackage KeyPackage_t;

/** <No documentation available> */
uint16_t
key_package_cipher_suite (
    KeyPackage_t const * __safer_ffi_gen_self);

/** <No documentation available> */
KeyPackage_t *
key_package_clone (
    KeyPackage_t const * x);

/** <No documentation available> */
int32_t
key_package_expiration (
    KeyPackage_t const * __safer_ffi_gen_self,
    uint64_t * __safer_ffi_gen_out);

/** <No documentation available> */
void
key_package_free (
    KeyPackage_t * _x);

/** <No documentation available> */
typedef struct KeyPackageRef KeyPackageRef_t;

/** <No documentation available> */
KeyPackageRef_t *
key_package_ref_clone (
    KeyPackageRef_t const * x);

/** <No documentation available> */
void
key_package_ref_free (
    KeyPackageRef_t * _x);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_KeyPackageRef {
    /** \brief
     *  Pointer to the first element (if any).
     */
    KeyPackageRef_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_KeyPackageRef_t;

/** <No documentation available> */
KeyPackageRef_t const *
key_package_ref_slice_get (
    slice_ref_KeyPackageRef_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_KeyPackageRef {
    /** \brief
     *  Pointer to the first element (if any).
     */
    KeyPackageRef_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_KeyPackageRef_t;

/** <No documentation available> */
KeyPackageRef_t *
key_package_ref_slice_get_mut (
    slice_mut_KeyPackageRef_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_KeyPackageRef {
    /** <No documentation available> */
    KeyPackageRef_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_KeyPackageRef_t;

/** <No documentation available> */
slice_ref_KeyPackageRef_t
key_package_ref_vec_as_slice (
    Vec_KeyPackageRef_t const * v);

/** <No documentation available> */
slice_mut_KeyPackageRef_t
key_package_ref_vec_as_slice_mut (
    Vec_KeyPackageRef_t * v);

/** <No documentation available> */
void
key_package_ref_vec_free (
    Vec_KeyPackageRef_t _v);

/** <No documentation available> */
Vec_KeyPackageRef_t
key_package_ref_vec_new (void);

/** <No documentation available> */
void
key_package_ref_vec_push (
    Vec_KeyPackageRef_t * v,
    KeyPackageRef_t * item);

/** <No documentation available> */
SigningIdentity_t const *
key_package_signing_identity (
    KeyPackage_t const * __safer_ffi_gen_self);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_KeyPackage {
    /** \brief
     *  Pointer to the first element (if any).
     */
    KeyPackage_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_KeyPackage_t;

/** <No documentation available> */
KeyPackage_t const *
key_package_slice_get (
    slice_ref_KeyPackage_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_KeyPackage {
    /** \brief
     *  Pointer to the first element (if any).
     */
    KeyPackage_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_KeyPackage_t;

/** <No documentation available> */
KeyPackage_t *
key_package_slice_get_mut (
    slice_mut_KeyPackage_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_KeyPackage {
    /** <No documentation available> */
    KeyPackage_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_KeyPackage_t;

/** <No documentation available> */
slice_ref_KeyPackage_t
key_package_vec_as_slice (
    Vec_KeyPackage_t const * v);

/** <No documentation available> */
slice_mut_KeyPackage_t
key_package_vec_as_slice_mut (
    Vec_KeyPackage_t * v);

/** <No documentation available> */
void
key_package_vec_free (
    Vec_KeyPackage_t _v);

/** <No documentation available> */
Vec_KeyPackage_t
key_package_vec_new (void);

/** <No documentation available> */
void
key_package_vec_push (
    Vec_KeyPackage_t * v,
    KeyPackage_t * item);

/** <No documentation available> */
uint16_t
key_package_version (
    KeyPackage_t const * __safer_ffi_gen_self);

/** <No documentation available> */
Vec_uint8_t
last_error (void);

/** \brief
 *  An MLS client used to create key packages and manage groups.
 *
 *  See [`mls_rs::Client`] for details.
 */
typedef struct LiteClient LiteClient_t;

/** \brief
 *  An MLS end-to-end encrypted group.
 *
 *  The group is used to send and process incoming messages and to
 *  add/remove users.
 *
 *  See [`mls_rs::Group`] for details.
 */
typedef struct LiteGroup LiteGroup_t;

/** <No documentation available> */
int32_t
lite_client_create_group (
    LiteClient_t const * __safer_ffi_gen_self,
    Vec_uint8_t group_id,
    LiteGroup_t * * __safer_ffi_gen_out);

/** <No documentation available> */
void
lite_client_free (
    LiteClient_t * _x);

/** <No documentation available> */
typedef struct LiteMessage LiteMessage_t;

/** <No documentation available> */
int32_t
lite_client_generate_key_package_message (
    LiteClient_t const * __safer_ffi_gen_self,
    LiteMessage_t * * __safer_ffi_gen_out);

/** <No documentation available> */
typedef struct SignatureKeypair SignatureKeypair_t;

/** <No documentation available> */
int32_t
lite_client_generate_signature_keypair (
    uint16_t cipher_suite,
    SignatureKeypair_t * * __safer_ffi_gen_out);

/** <No documentation available> */
typedef struct LiteNewMemberInfo LiteNewMemberInfo_t;

/** \brief
 *  Simplified for lighter documentation, but the actual impls
 *  range from `Tuple1` up to `Tuple6`.
 */
typedef struct Tuple2_LiteGroup_ptr_LiteNewMemberInfo_ptr {
    /** <No documentation available> */
    LiteGroup_t * _0;

    /** <No documentation available> */
    LiteNewMemberInfo_t * _1;
} Tuple2_LiteGroup_ptr_LiteNewMemberInfo_ptr_t;

/** <No documentation available> */
int32_t
lite_client_join_group (
    LiteClient_t const * __safer_ffi_gen_self,
    MlsMessage_t * welcome_message,
    Tuple2_LiteGroup_ptr_LiteNewMemberInfo_ptr_t * __safer_ffi_gen_out);

/** <No documentation available> */
LiteClient_t *
lite_client_new (
    Vec_uint8_t id,
    SignatureKeypair_t * signature_keypair,
    uint16_t cipher_suite);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_LiteClient {
    /** \brief
     *  Pointer to the first element (if any).
     */
    LiteClient_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_LiteClient_t;

/** <No documentation available> */
LiteClient_t const *
lite_client_slice_get (
    slice_ref_LiteClient_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_LiteClient {
    /** \brief
     *  Pointer to the first element (if any).
     */
    LiteClient_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_LiteClient_t;

/** <No documentation available> */
LiteClient_t *
lite_client_slice_get_mut (
    slice_mut_LiteClient_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_LiteClient {
    /** <No documentation available> */
    LiteClient_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_LiteClient_t;

/** <No documentation available> */
slice_ref_LiteClient_t
lite_client_vec_as_slice (
    Vec_LiteClient_t const * v);

/** <No documentation available> */
slice_mut_LiteClient_t
lite_client_vec_as_slice_mut (
    Vec_LiteClient_t * v);

/** <No documentation available> */
void
lite_client_vec_free (
    Vec_LiteClient_t _v);

/** <No documentation available> */
Vec_LiteClient_t
lite_client_vec_new (void);

/** <No documentation available> */
void
lite_client_vec_push (
    Vec_LiteClient_t * v,
    LiteClient_t * item);

/** <No documentation available> */
int32_t
lite_group_add_member (
    LiteGroup_t * __safer_ffi_gen_self,
    LiteMessage_t * member,
    CommitOutput_t * * __safer_ffi_gen_out);

/** <No documentation available> */
int32_t
lite_group_apply_pending_commit (
    LiteGroup_t * __safer_ffi_gen_self);

/** <No documentation available> */
int32_t
lite_group_commit (
    LiteGroup_t * __safer_ffi_gen_self,
    CommitOutput_t * * __safer_ffi_gen_out);

/** <No documentation available> */
void
lite_group_free (
    LiteGroup_t * _x);

/** <No documentation available> */
int32_t
lite_group_propose_add_member (
    LiteGroup_t * __safer_ffi_gen_self,
    LiteMessage_t * member,
    LiteMessage_t * * __safer_ffi_gen_out);

/** <No documentation available> */
int32_t
lite_group_propose_remove_member (
    LiteGroup_t * __safer_ffi_gen_self,
    LiteMessage_t * member,
    LiteMessage_t * * __safer_ffi_gen_out);

/** <No documentation available> */
int32_t
lite_group_remove_member (
    LiteGroup_t * __safer_ffi_gen_self,
    LiteMessage_t * member,
    CommitOutput_t * * __safer_ffi_gen_out);

/** <No documentation available> */
typedef struct Roster Roster_t;

/** <No documentation available> */
Roster_t *
lite_group_roster (
    LiteGroup_t const * __safer_ffi_gen_self);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_LiteGroup {
    /** \brief
     *  Pointer to the first element (if any).
     */
    LiteGroup_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_LiteGroup_t;

/** <No documentation available> */
LiteGroup_t const *
lite_group_slice_get (
    slice_ref_LiteGroup_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_LiteGroup {
    /** \brief
     *  Pointer to the first element (if any).
     */
    LiteGroup_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_LiteGroup_t;

/** <No documentation available> */
LiteGroup_t *
lite_group_slice_get_mut (
    slice_mut_LiteGroup_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_LiteGroup {
    /** <No documentation available> */
    LiteGroup_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_LiteGroup_t;

/** <No documentation available> */
slice_ref_LiteGroup_t
lite_group_vec_as_slice (
    Vec_LiteGroup_t const * v);

/** <No documentation available> */
slice_mut_LiteGroup_t
lite_group_vec_as_slice_mut (
    Vec_LiteGroup_t * v);

/** <No documentation available> */
void
lite_group_vec_free (
    Vec_LiteGroup_t _v);

/** <No documentation available> */
Vec_LiteGroup_t
lite_group_vec_new (void);

/** <No documentation available> */
void
lite_group_vec_push (
    Vec_LiteGroup_t * v,
    LiteGroup_t * item);

/** <No documentation available> */
void
lite_message_free (
    LiteMessage_t * _x);

/** <No documentation available> */
KeyPackage_t *
lite_message_into_key_package (
    LiteMessage_t * __safer_ffi_gen_self);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_LiteMessage {
    /** \brief
     *  Pointer to the first element (if any).
     */
    LiteMessage_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_LiteMessage_t;

/** <No documentation available> */
LiteMessage_t const *
lite_message_slice_get (
    slice_ref_LiteMessage_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_LiteMessage {
    /** \brief
     *  Pointer to the first element (if any).
     */
    LiteMessage_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_LiteMessage_t;

/** <No documentation available> */
LiteMessage_t *
lite_message_slice_get_mut (
    slice_mut_LiteMessage_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_LiteMessage {
    /** <No documentation available> */
    LiteMessage_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_LiteMessage_t;

/** <No documentation available> */
slice_ref_LiteMessage_t
lite_message_vec_as_slice (
    Vec_LiteMessage_t const * v);

/** <No documentation available> */
slice_mut_LiteMessage_t
lite_message_vec_as_slice_mut (
    Vec_LiteMessage_t * v);

/** <No documentation available> */
void
lite_message_vec_free (
    Vec_LiteMessage_t _v);

/** <No documentation available> */
Vec_LiteMessage_t
lite_message_vec_new (void);

/** <No documentation available> */
void
lite_message_vec_push (
    Vec_LiteMessage_t * v,
    LiteMessage_t * item);

/** <No documentation available> */
void
lite_new_member_info_free (
    LiteNewMemberInfo_t * _x);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_LiteNewMemberInfo {
    /** \brief
     *  Pointer to the first element (if any).
     */
    LiteNewMemberInfo_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_LiteNewMemberInfo_t;

/** <No documentation available> */
LiteNewMemberInfo_t const *
lite_new_member_info_slice_get (
    slice_ref_LiteNewMemberInfo_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_LiteNewMemberInfo {
    /** \brief
     *  Pointer to the first element (if any).
     */
    LiteNewMemberInfo_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_LiteNewMemberInfo_t;

/** <No documentation available> */
LiteNewMemberInfo_t *
lite_new_member_info_slice_get_mut (
    slice_mut_LiteNewMemberInfo_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_LiteNewMemberInfo {
    /** <No documentation available> */
    LiteNewMemberInfo_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_LiteNewMemberInfo_t;

/** <No documentation available> */
slice_ref_LiteNewMemberInfo_t
lite_new_member_info_vec_as_slice (
    Vec_LiteNewMemberInfo_t const * v);

/** <No documentation available> */
slice_mut_LiteNewMemberInfo_t
lite_new_member_info_vec_as_slice_mut (
    Vec_LiteNewMemberInfo_t * v);

/** <No documentation available> */
void
lite_new_member_info_vec_free (
    Vec_LiteNewMemberInfo_t _v);

/** <No documentation available> */
Vec_LiteNewMemberInfo_t
lite_new_member_info_vec_new (void);

/** <No documentation available> */
void
lite_new_member_info_vec_push (
    Vec_LiteNewMemberInfo_t * v,
    LiteNewMemberInfo_t * item);

/** \brief
 *  A member of a MLS group.
 */
typedef struct Member Member_t;

/** <No documentation available> */
Capabilities_t const *
member_capabilities (
    Member_t const * __safer_ffi_gen_self);

/** <No documentation available> */
Member_t *
member_clone (
    Member_t const * x);

/** <No documentation available> */
ExtensionList_t const *
member_extensions (
    Member_t const * __safer_ffi_gen_self);

/** <No documentation available> */
void
member_free (
    Member_t * _x);

/** <No documentation available> */
uint32_t
member_index (
    Member_t const * __safer_ffi_gen_self);

/** <No documentation available> */
Member_t *
member_new (
    uint32_t index,
    SigningIdentity_t * signing_identity,
    Capabilities_t * capabilities,
    ExtensionList_t * extensions);

/** <No documentation available> */
SigningIdentity_t const *
member_signing_identity (
    Member_t const * __safer_ffi_gen_self);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_Member {
    /** \brief
     *  Pointer to the first element (if any).
     */
    Member_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_Member_t;

/** <No documentation available> */
Member_t const *
member_slice_get (
    slice_ref_Member_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_Member {
    /** \brief
     *  Pointer to the first element (if any).
     */
    Member_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_Member_t;

/** <No documentation available> */
Member_t *
member_slice_get_mut (
    slice_mut_Member_t items,
    size_t index);

/** \brief
 *  Update of a member due to a commit.
 */
typedef struct MemberUpdate MemberUpdate_t;

/** <No documentation available> */
Member_t const *
member_update_after_update (
    MemberUpdate_t const * __safer_ffi_gen_self);

/** <No documentation available> */
Member_t const *
member_update_before_update (
    MemberUpdate_t const * __safer_ffi_gen_self);

/** <No documentation available> */
MemberUpdate_t *
member_update_clone (
    MemberUpdate_t const * x);

/** <No documentation available> */
void
member_update_free (
    MemberUpdate_t * _x);

/** <No documentation available> */
uint32_t
member_update_index (
    MemberUpdate_t const * __safer_ffi_gen_self);

/** <No documentation available> */
MemberUpdate_t *
member_update_new (
    Member_t * prior,
    Member_t * new);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_MemberUpdate {
    /** \brief
     *  Pointer to the first element (if any).
     */
    MemberUpdate_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_MemberUpdate_t;

/** <No documentation available> */
MemberUpdate_t const *
member_update_slice_get (
    slice_ref_MemberUpdate_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_MemberUpdate {
    /** \brief
     *  Pointer to the first element (if any).
     */
    MemberUpdate_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_MemberUpdate_t;

/** <No documentation available> */
MemberUpdate_t *
member_update_slice_get_mut (
    slice_mut_MemberUpdate_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_MemberUpdate {
    /** <No documentation available> */
    MemberUpdate_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_MemberUpdate_t;

/** <No documentation available> */
slice_ref_MemberUpdate_t
member_update_vec_as_slice (
    Vec_MemberUpdate_t const * v);

/** <No documentation available> */
slice_mut_MemberUpdate_t
member_update_vec_as_slice_mut (
    Vec_MemberUpdate_t * v);

/** <No documentation available> */
void
member_update_vec_free (
    Vec_MemberUpdate_t _v);

/** <No documentation available> */
Vec_MemberUpdate_t
member_update_vec_new (void);

/** <No documentation available> */
void
member_update_vec_push (
    Vec_MemberUpdate_t * v,
    MemberUpdate_t * item);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_Member {
    /** <No documentation available> */
    Member_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_Member_t;

/** <No documentation available> */
slice_ref_Member_t
member_vec_as_slice (
    Vec_Member_t const * v);

/** <No documentation available> */
slice_mut_Member_t
member_vec_as_slice_mut (
    Vec_Member_t * v);

/** <No documentation available> */
void
member_vec_free (
    Vec_Member_t _v);

/** <No documentation available> */
Vec_Member_t
member_vec_new (void);

/** <No documentation available> */
void
member_vec_push (
    Vec_Member_t * v,
    Member_t * item);

/** \brief
 *  AEAD key derived by the MLS secret tree.
 */
typedef struct MessageKeyData MessageKeyData_t;

/** <No documentation available> */
MessageKeyData_t *
message_key_data_clone (
    MessageKeyData_t const * x);

/** <No documentation available> */
void
message_key_data_free (
    MessageKeyData_t * _x);

/** <No documentation available> */
uint32_t
message_key_data_generation (
    MessageKeyData_t const * __safer_ffi_gen_self);

/** <No documentation available> */
slice_ref_uint8_t
message_key_data_key (
    MessageKeyData_t const * __safer_ffi_gen_self);

/** <No documentation available> */
slice_ref_uint8_t
message_key_data_nonce (
    MessageKeyData_t const * __safer_ffi_gen_self);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_MessageKeyData {
    /** \brief
     *  Pointer to the first element (if any).
     */
    MessageKeyData_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_MessageKeyData_t;

/** <No documentation available> */
MessageKeyData_t const *
message_key_data_slice_get (
    slice_ref_MessageKeyData_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_MessageKeyData {
    /** \brief
     *  Pointer to the first element (if any).
     */
    MessageKeyData_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_MessageKeyData_t;

/** <No documentation available> */
MessageKeyData_t *
message_key_data_slice_get_mut (
    slice_mut_MessageKeyData_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_MessageKeyData {
    /** <No documentation available> */
    MessageKeyData_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_MessageKeyData_t;

/** <No documentation available> */
slice_ref_MessageKeyData_t
message_key_data_vec_as_slice (
    Vec_MessageKeyData_t const * v);

/** <No documentation available> */
slice_mut_MessageKeyData_t
message_key_data_vec_as_slice_mut (
    Vec_MessageKeyData_t * v);

/** <No documentation available> */
void
message_key_data_vec_free (
    Vec_MessageKeyData_t _v);

/** <No documentation available> */
Vec_MessageKeyData_t
message_key_data_vec_new (void);

/** <No documentation available> */
void
message_key_data_vec_push (
    Vec_MessageKeyData_t * v,
    MessageKeyData_t * item);

/** <No documentation available> */
MlsMessage_t *
mls_message_clone (
    MlsMessage_t const * x);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_CustomProposal_const_ptr {
    /** <No documentation available> */
    CustomProposal_t const * * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_CustomProposal_const_ptr_t;

/** <No documentation available> */
Vec_CustomProposal_const_ptr_t
mls_message_custom_proposals_by_value (
    MlsMessage_t const * __safer_ffi_gen_self);

/** <No documentation available> */
void
mls_message_free (
    MlsMessage_t * _x);

/** <No documentation available> */
int32_t
mls_message_from_bytes (
    slice_ref_uint8_t bytes,
    MlsMessage_t * * __safer_ffi_gen_out);

/** <No documentation available> */
slice_ref_uint8_t
mls_message_group_id (
    MlsMessage_t const * __safer_ffi_gen_self);

/** <No documentation available> */
GroupInfo_t *
mls_message_into_group_info (
    MlsMessage_t * __safer_ffi_gen_self);

/** <No documentation available> */
KeyPackage_t *
mls_message_into_key_package (
    MlsMessage_t * __safer_ffi_gen_self);

/** <No documentation available> */
MlsMessage_t const *
mls_message_slice_get (
    slice_ref_MlsMessage_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_MlsMessage {
    /** \brief
     *  Pointer to the first element (if any).
     */
    MlsMessage_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_MlsMessage_t;

/** <No documentation available> */
MlsMessage_t *
mls_message_slice_get_mut (
    slice_mut_MlsMessage_t items,
    size_t index);

/** <No documentation available> */
int32_t
mls_message_to_bytes (
    MlsMessage_t const * __safer_ffi_gen_self,
    Vec_uint8_t * __safer_ffi_gen_out);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_MlsMessage {
    /** <No documentation available> */
    MlsMessage_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_MlsMessage_t;

/** <No documentation available> */
slice_ref_MlsMessage_t
mls_message_vec_as_slice (
    Vec_MlsMessage_t const * v);

/** <No documentation available> */
slice_mut_MlsMessage_t
mls_message_vec_as_slice_mut (
    Vec_MlsMessage_t * v);

/** <No documentation available> */
void
mls_message_vec_free (
    Vec_MlsMessage_t _v);

/** <No documentation available> */
Vec_MlsMessage_t
mls_message_vec_new (void);

/** <No documentation available> */
void
mls_message_vec_push (
    Vec_MlsMessage_t * v,
    MlsMessage_t * item);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_KeyPackageRef_const_ptr {
    /** <No documentation available> */
    KeyPackageRef_t const * * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_KeyPackageRef_const_ptr_t;

/** <No documentation available> */
Vec_KeyPackageRef_const_ptr_t
mls_message_welcome_key_package_references (
    MlsMessage_t const * __safer_ffi_gen_self);

/** \brief
 *  Content description of an [`MlsMessage`]
 */
/** \remark Has the same ABI as `uint16_t` **/
#ifdef DOXYGEN
typedef
#endif
enum WireFormat {
    /** <No documentation available> */
    WIRE_FORMAT_PUBLIC_MESSAGE = 1,
    /** <No documentation available> */
    WIRE_FORMAT_PRIVATE_MESSAGE = 2,
    /** <No documentation available> */
    WIRE_FORMAT_WELCOME = 3,
    /** <No documentation available> */
    WIRE_FORMAT_GROUP_INFO = 4,
    /** <No documentation available> */
    WIRE_FORMAT_KEY_PACKAGE = 5,
}
#ifndef DOXYGEN
; typedef uint16_t
#endif
WireFormat_t;

/** <No documentation available> */
WireFormat_t
mls_message_wire_format (
    MlsMessage_t const * __safer_ffi_gen_self);

/** <No documentation available> */
void
mls_time_free (
    uint64_t _x);

/** \brief
 *  Information provided to new members upon joining a group.
 */
typedef struct NewMemberInfo NewMemberInfo_t;

/** <No documentation available> */
NewMemberInfo_t *
new_member_info_clone (
    NewMemberInfo_t const * x);

/** <No documentation available> */
void
new_member_info_free (
    NewMemberInfo_t * _x);

/** <No documentation available> */
ExtensionList_t const *
new_member_info_group_info_extensions (
    NewMemberInfo_t const * __safer_ffi_gen_self);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_NewMemberInfo {
    /** \brief
     *  Pointer to the first element (if any).
     */
    NewMemberInfo_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_NewMemberInfo_t;

/** <No documentation available> */
NewMemberInfo_t const *
new_member_info_slice_get (
    slice_ref_NewMemberInfo_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_NewMemberInfo {
    /** \brief
     *  Pointer to the first element (if any).
     */
    NewMemberInfo_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_NewMemberInfo_t;

/** <No documentation available> */
NewMemberInfo_t *
new_member_info_slice_get_mut (
    slice_mut_NewMemberInfo_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_NewMemberInfo {
    /** <No documentation available> */
    NewMemberInfo_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_NewMemberInfo_t;

/** <No documentation available> */
slice_ref_NewMemberInfo_t
new_member_info_vec_as_slice (
    Vec_NewMemberInfo_t const * v);

/** <No documentation available> */
slice_mut_NewMemberInfo_t
new_member_info_vec_as_slice_mut (
    Vec_NewMemberInfo_t * v);

/** <No documentation available> */
void
new_member_info_vec_free (
    Vec_NewMemberInfo_t _v);

/** <No documentation available> */
Vec_NewMemberInfo_t
new_member_info_vec_new (void);

/** <No documentation available> */
void
new_member_info_vec_push (
    Vec_NewMemberInfo_t * v,
    NewMemberInfo_t * item);

/** \brief
 *  Padding used when sending an encrypted group message.
 */
/** \remark Has the same ABI as `uint8_t` **/
#ifdef DOXYGEN
typedef
#endif
enum PaddingMode {
    /** \brief
     *  Step function based on the size of the message being sent.
     *  The amount of padding used will increase with the size of the original
     *  message.
     */
    PADDING_MODE_STEP_FUNCTION,
    /** \brief
     *  No padding.
     */
    PADDING_MODE_NONE,
}
#ifndef DOXYGEN
; typedef uint8_t
#endif
PaddingMode_t;

/** <No documentation available> */
void
padding_mode_free (
    PaddingMode_t _x);

/** <No documentation available> */
bool
proposal_info_ffi_is_by_reference (
    ProposalInfo_Proposal_t const * __safer_ffi_gen_self);

/** <No documentation available> */
bool
proposal_info_ffi_is_by_value (
    ProposalInfo_Proposal_t const * __safer_ffi_gen_self);

/** \brief
 *  Unique identifier for a proposal message.
 */
typedef struct ProposalRef ProposalRef_t;

/** <No documentation available> */
ProposalRef_t const *
proposal_info_ffi_proposal_ref (
    ProposalInfo_Proposal_t const * __safer_ffi_gen_self);

/** \brief
 *  The layout of mls_rs::group::framing::Sender is subject to change
 */
typedef struct Sender Sender_t;

/** <No documentation available> */
Sender_t const *
proposal_info_ffi_sender (
    ProposalInfo_Proposal_t const * __safer_ffi_gen_self);

/** \brief
 *  The layout of mls_rs::group::proposal_filter::bundle::ProposalSource is subject to change
 */
typedef struct ProposalSource ProposalSource_t;

/** <No documentation available> */
ProposalSource_t const *
proposal_info_ffi_source (
    ProposalInfo_Proposal_t const * __safer_ffi_gen_self);

/** \brief
 *  Description of a processed MLS proposal message.
 */
typedef struct ProposalMessageDescription ProposalMessageDescription_t;

/** <No documentation available> */
ProposalMessageDescription_t *
proposal_message_description_clone (
    ProposalMessageDescription_t const * x);

/** <No documentation available> */
void
proposal_message_description_free (
    ProposalMessageDescription_t * _x);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_ProposalMessageDescription {
    /** \brief
     *  Pointer to the first element (if any).
     */
    ProposalMessageDescription_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_ProposalMessageDescription_t;

/** <No documentation available> */
ProposalMessageDescription_t const *
proposal_message_description_slice_get (
    slice_ref_ProposalMessageDescription_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_ProposalMessageDescription {
    /** \brief
     *  Pointer to the first element (if any).
     */
    ProposalMessageDescription_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_ProposalMessageDescription_t;

/** <No documentation available> */
ProposalMessageDescription_t *
proposal_message_description_slice_get_mut (
    slice_mut_ProposalMessageDescription_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_ProposalMessageDescription {
    /** <No documentation available> */
    ProposalMessageDescription_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_ProposalMessageDescription_t;

/** <No documentation available> */
slice_ref_ProposalMessageDescription_t
proposal_message_description_vec_as_slice (
    Vec_ProposalMessageDescription_t const * v);

/** <No documentation available> */
slice_mut_ProposalMessageDescription_t
proposal_message_description_vec_as_slice_mut (
    Vec_ProposalMessageDescription_t * v);

/** <No documentation available> */
void
proposal_message_description_vec_free (
    Vec_ProposalMessageDescription_t _v);

/** <No documentation available> */
Vec_ProposalMessageDescription_t
proposal_message_description_vec_new (void);

/** <No documentation available> */
void
proposal_message_description_vec_push (
    Vec_ProposalMessageDescription_t * v,
    ProposalMessageDescription_t * item);

/** <No documentation available> */
slice_ref_uint8_t
proposal_ref_as_slice (
    ProposalRef_t const * __safer_ffi_gen_self);

/** <No documentation available> */
ProposalRef_t *
proposal_ref_clone (
    ProposalRef_t const * x);

/** <No documentation available> */
void
proposal_ref_free (
    ProposalRef_t * _x);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_ProposalRef {
    /** \brief
     *  Pointer to the first element (if any).
     */
    ProposalRef_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_ProposalRef_t;

/** <No documentation available> */
ProposalRef_t const *
proposal_ref_slice_get (
    slice_ref_ProposalRef_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_ProposalRef {
    /** \brief
     *  Pointer to the first element (if any).
     */
    ProposalRef_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_ProposalRef_t;

/** <No documentation available> */
ProposalRef_t *
proposal_ref_slice_get_mut (
    slice_mut_ProposalRef_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_ProposalRef {
    /** <No documentation available> */
    ProposalRef_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_ProposalRef_t;

/** <No documentation available> */
slice_ref_ProposalRef_t
proposal_ref_vec_as_slice (
    Vec_ProposalRef_t const * v);

/** <No documentation available> */
slice_mut_ProposalRef_t
proposal_ref_vec_as_slice_mut (
    Vec_ProposalRef_t * v);

/** <No documentation available> */
void
proposal_ref_vec_free (
    Vec_ProposalRef_t _v);

/** <No documentation available> */
Vec_ProposalRef_t
proposal_ref_vec_new (void);

/** <No documentation available> */
void
proposal_ref_vec_push (
    Vec_ProposalRef_t * v,
    ProposalRef_t * item);

/** <No documentation available> */
ProposalSource_t *
proposal_source_clone (
    ProposalSource_t const * x);

/** <No documentation available> */
/** \remark Has the same ABI as `int32_t` **/
#ifdef DOXYGEN
typedef
#endif
enum ProposalSourceDiscriminant {
    /** <No documentation available> */
    PROPOSAL_SOURCE_DISCRIMINANT_BY_VALUE,
    /** <No documentation available> */
    PROPOSAL_SOURCE_DISCRIMINANT_BY_REFERENCE,
    /** <No documentation available> */
    PROPOSAL_SOURCE_DISCRIMINANT_LOCAL,
}
#ifndef DOXYGEN
; typedef int32_t
#endif
ProposalSourceDiscriminant_t;

/** <No documentation available> */
ProposalSourceDiscriminant_t
proposal_source_discriminant (
    ProposalSource_t const * x);

/** <No documentation available> */
void
proposal_source_free (
    ProposalSource_t * _x);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_ProposalSource {
    /** \brief
     *  Pointer to the first element (if any).
     */
    ProposalSource_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_ProposalSource_t;

/** <No documentation available> */
ProposalSource_t const *
proposal_source_slice_get (
    slice_ref_ProposalSource_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_ProposalSource {
    /** \brief
     *  Pointer to the first element (if any).
     */
    ProposalSource_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_ProposalSource_t;

/** <No documentation available> */
ProposalSource_t *
proposal_source_slice_get_mut (
    slice_mut_ProposalSource_t items,
    size_t index);

/** <No documentation available> */
ProposalRef_t const *
proposal_source_to_by_reference (
    ProposalSource_t const * x);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_ProposalSource {
    /** <No documentation available> */
    ProposalSource_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_ProposalSource_t;

/** <No documentation available> */
slice_ref_ProposalSource_t
proposal_source_vec_as_slice (
    Vec_ProposalSource_t const * v);

/** <No documentation available> */
slice_mut_ProposalSource_t
proposal_source_vec_as_slice_mut (
    Vec_ProposalSource_t * v);

/** <No documentation available> */
void
proposal_source_vec_free (
    Vec_ProposalSource_t _v);

/** <No documentation available> */
Vec_ProposalSource_t
proposal_source_vec_new (void);

/** <No documentation available> */
void
proposal_source_vec_push (
    Vec_ProposalSource_t * v,
    ProposalSource_t * item);

/** <No documentation available> */
void
proposal_type_free (
    uint16_t _x);

/** <No documentation available> */
void
protocol_version_free (
    uint16_t _x);

/** \brief
 *  Representation of an MLS ratchet tree.
 *
 *  Used to provide new members
 *  a copy of the current group state in-band.
 */
typedef struct RatchetTreeExt RatchetTreeExt_t;

/** <No documentation available> */
RatchetTreeExt_t *
ratchet_tree_ext_clone (
    RatchetTreeExt_t const * x);

/** <No documentation available> */
void
ratchet_tree_ext_free (
    RatchetTreeExt_t * _x);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_RatchetTreeExt {
    /** \brief
     *  Pointer to the first element (if any).
     */
    RatchetTreeExt_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_RatchetTreeExt_t;

/** <No documentation available> */
RatchetTreeExt_t const *
ratchet_tree_ext_slice_get (
    slice_ref_RatchetTreeExt_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_RatchetTreeExt {
    /** \brief
     *  Pointer to the first element (if any).
     */
    RatchetTreeExt_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_RatchetTreeExt_t;

/** <No documentation available> */
RatchetTreeExt_t *
ratchet_tree_ext_slice_get_mut (
    slice_mut_RatchetTreeExt_t items,
    size_t index);

/** <No documentation available> */
ExportedTree_t const *
ratchet_tree_ext_tree_data (
    RatchetTreeExt_t const * __safer_ffi_gen_self);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_RatchetTreeExt {
    /** <No documentation available> */
    RatchetTreeExt_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_RatchetTreeExt_t;

/** <No documentation available> */
slice_ref_RatchetTreeExt_t
ratchet_tree_ext_vec_as_slice (
    Vec_RatchetTreeExt_t const * v);

/** <No documentation available> */
slice_mut_RatchetTreeExt_t
ratchet_tree_ext_vec_as_slice_mut (
    Vec_RatchetTreeExt_t * v);

/** <No documentation available> */
void
ratchet_tree_ext_vec_free (
    Vec_RatchetTreeExt_t _v);

/** <No documentation available> */
Vec_RatchetTreeExt_t
ratchet_tree_ext_vec_new (void);

/** <No documentation available> */
void
ratchet_tree_ext_vec_push (
    Vec_RatchetTreeExt_t * v,
    RatchetTreeExt_t * item);

/** \brief
 *  The layout of mls_rs::group::message_processor::ReceivedMessage is subject to change
 */
typedef struct ReceivedMessage ReceivedMessage_t;

/** <No documentation available> */
ReceivedMessage_t *
received_message_clone (
    ReceivedMessage_t const * x);

/** <No documentation available> */
/** \remark Has the same ABI as `int32_t` **/
#ifdef DOXYGEN
typedef
#endif
enum ReceivedMessageDiscriminant {
    /** <No documentation available> */
    RECEIVED_MESSAGE_DISCRIMINANT_APPLICATION_MESSAGE,
    /** <No documentation available> */
    RECEIVED_MESSAGE_DISCRIMINANT_COMMIT,
    /** <No documentation available> */
    RECEIVED_MESSAGE_DISCRIMINANT_PROPOSAL,
}
#ifndef DOXYGEN
; typedef int32_t
#endif
ReceivedMessageDiscriminant_t;

/** <No documentation available> */
ReceivedMessageDiscriminant_t
received_message_discriminant (
    ReceivedMessage_t const * x);

/** <No documentation available> */
void
received_message_free (
    ReceivedMessage_t * _x);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_ReceivedMessage {
    /** \brief
     *  Pointer to the first element (if any).
     */
    ReceivedMessage_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_ReceivedMessage_t;

/** <No documentation available> */
ReceivedMessage_t const *
received_message_slice_get (
    slice_ref_ReceivedMessage_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_ReceivedMessage {
    /** \brief
     *  Pointer to the first element (if any).
     */
    ReceivedMessage_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_ReceivedMessage_t;

/** <No documentation available> */
ReceivedMessage_t *
received_message_slice_get_mut (
    slice_mut_ReceivedMessage_t items,
    size_t index);

/** <No documentation available> */
ApplicationMessageDescription_t const *
received_message_to_application_message (
    ReceivedMessage_t const * x);

/** <No documentation available> */
CommitMessageDescription_t const *
received_message_to_commit (
    ReceivedMessage_t const * x);

/** <No documentation available> */
ProposalMessageDescription_t const *
received_message_to_proposal (
    ReceivedMessage_t const * x);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_ReceivedMessage {
    /** <No documentation available> */
    ReceivedMessage_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_ReceivedMessage_t;

/** <No documentation available> */
slice_ref_ReceivedMessage_t
received_message_vec_as_slice (
    Vec_ReceivedMessage_t const * v);

/** <No documentation available> */
slice_mut_ReceivedMessage_t
received_message_vec_as_slice_mut (
    Vec_ReceivedMessage_t * v);

/** <No documentation available> */
void
received_message_vec_free (
    Vec_ReceivedMessage_t _v);

/** <No documentation available> */
Vec_ReceivedMessage_t
received_message_vec_new (void);

/** <No documentation available> */
void
received_message_vec_push (
    Vec_ReceivedMessage_t * v,
    ReceivedMessage_t * item);

/** \brief
 *  Require members to have certain capabilities.
 *
 *  Used within a
 *  [Group Context Extensions Proposal](crate::group::proposal::Proposal)
 *  in order to require that all current and future members of a group MUST
 *  support specific extensions, proposals, or credentials.
 *
 *  # Warning
 *
 *  Extension, proposal, and credential types defined by the MLS RFC and
 *  provided are considered required by default and should NOT be used
 *  within this extension.
 */
typedef struct RequiredCapabilitiesExt RequiredCapabilitiesExt_t;

/** <No documentation available> */
RequiredCapabilitiesExt_t *
required_capabilities_ext_clone (
    RequiredCapabilitiesExt_t const * x);

/** <No documentation available> */
slice_ref_uint16_t
required_capabilities_ext_credentials (
    RequiredCapabilitiesExt_t const * __safer_ffi_gen_self);

/** <No documentation available> */
slice_ref_uint16_t
required_capabilities_ext_extensions (
    RequiredCapabilitiesExt_t const * __safer_ffi_gen_self);

/** <No documentation available> */
void
required_capabilities_ext_free (
    RequiredCapabilitiesExt_t * _x);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_uint16 {
    /** <No documentation available> */
    uint16_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_uint16_t;

/** <No documentation available> */
RequiredCapabilitiesExt_t *
required_capabilities_ext_new (
    Vec_uint16_t extensions,
    Vec_uint16_t proposals,
    Vec_uint16_t credentials);

/** <No documentation available> */
slice_ref_uint16_t
required_capabilities_ext_proposals (
    RequiredCapabilitiesExt_t const * __safer_ffi_gen_self);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_RequiredCapabilitiesExt {
    /** \brief
     *  Pointer to the first element (if any).
     */
    RequiredCapabilitiesExt_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_RequiredCapabilitiesExt_t;

/** <No documentation available> */
RequiredCapabilitiesExt_t const *
required_capabilities_ext_slice_get (
    slice_ref_RequiredCapabilitiesExt_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_RequiredCapabilitiesExt {
    /** \brief
     *  Pointer to the first element (if any).
     */
    RequiredCapabilitiesExt_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_RequiredCapabilitiesExt_t;

/** <No documentation available> */
RequiredCapabilitiesExt_t *
required_capabilities_ext_slice_get_mut (
    slice_mut_RequiredCapabilitiesExt_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_RequiredCapabilitiesExt {
    /** <No documentation available> */
    RequiredCapabilitiesExt_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_RequiredCapabilitiesExt_t;

/** <No documentation available> */
slice_ref_RequiredCapabilitiesExt_t
required_capabilities_ext_vec_as_slice (
    Vec_RequiredCapabilitiesExt_t const * v);

/** <No documentation available> */
slice_mut_RequiredCapabilitiesExt_t
required_capabilities_ext_vec_as_slice_mut (
    Vec_RequiredCapabilitiesExt_t * v);

/** <No documentation available> */
void
required_capabilities_ext_vec_free (
    Vec_RequiredCapabilitiesExt_t _v);

/** <No documentation available> */
Vec_RequiredCapabilitiesExt_t
required_capabilities_ext_vec_new (void);

/** <No documentation available> */
void
required_capabilities_ext_vec_push (
    Vec_RequiredCapabilitiesExt_t * v,
    RequiredCapabilitiesExt_t * item);

/** <No documentation available> */
Roster_t *
roster_clone (
    Roster_t const * x);

/** <No documentation available> */
void
roster_free (
    Roster_t * _x);

/** <No documentation available> */
int32_t
roster_member_with_index (
    Roster_t const * __safer_ffi_gen_self,
    uint32_t index,
    Member_t * * __safer_ffi_gen_out);

/** <No documentation available> */
Vec_Member_t
roster_members (
    Roster_t const * __safer_ffi_gen_self);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_Roster {
    /** \brief
     *  Pointer to the first element (if any).
     */
    Roster_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_Roster_t;

/** <No documentation available> */
Roster_t const *
roster_slice_get (
    slice_ref_Roster_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_Roster {
    /** \brief
     *  Pointer to the first element (if any).
     */
    Roster_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_Roster_t;

/** <No documentation available> */
Roster_t *
roster_slice_get_mut (
    slice_mut_Roster_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_Roster {
    /** <No documentation available> */
    Roster_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_Roster_t;

/** <No documentation available> */
slice_ref_Roster_t
roster_vec_as_slice (
    Vec_Roster_t const * v);

/** <No documentation available> */
slice_mut_Roster_t
roster_vec_as_slice_mut (
    Vec_Roster_t * v);

/** <No documentation available> */
void
roster_vec_free (
    Vec_Roster_t _v);

/** <No documentation available> */
Vec_Roster_t
roster_vec_new (void);

/** <No documentation available> */
void
roster_vec_push (
    Vec_Roster_t * v,
    Roster_t * item);

/** \brief
 *  Wrapper struct that represents a zeroize-on-drop `Vec<u8>`
 */
typedef struct Secret Secret_t;

/** <No documentation available> */
slice_ref_uint8_t
secret_as_bytes (
    Secret_t const * __safer_ffi_gen_self);

/** <No documentation available> */
Secret_t *
secret_clone (
    Secret_t const * x);

/** <No documentation available> */
void
secret_free (
    Secret_t * _x);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_Secret {
    /** \brief
     *  Pointer to the first element (if any).
     */
    Secret_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_Secret_t;

/** <No documentation available> */
Secret_t const *
secret_slice_get (
    slice_ref_Secret_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_Secret {
    /** \brief
     *  Pointer to the first element (if any).
     */
    Secret_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_Secret_t;

/** <No documentation available> */
Secret_t *
secret_slice_get_mut (
    slice_mut_Secret_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_Secret {
    /** <No documentation available> */
    Secret_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_Secret_t;

/** <No documentation available> */
slice_ref_Secret_t
secret_vec_as_slice (
    Vec_Secret_t const * v);

/** <No documentation available> */
slice_mut_Secret_t
secret_vec_as_slice_mut (
    Vec_Secret_t * v);

/** <No documentation available> */
void
secret_vec_free (
    Vec_Secret_t _v);

/** <No documentation available> */
Vec_Secret_t
secret_vec_new (void);

/** <No documentation available> */
void
secret_vec_push (
    Vec_Secret_t * v,
    Secret_t * item);

/** <No documentation available> */
Sender_t *
sender_clone (
    Sender_t const * x);

/** <No documentation available> */
/** \remark Has the same ABI as `uint8_t` **/
#ifdef DOXYGEN
typedef
#endif
enum SenderDiscriminant {
    /** <No documentation available> */
    SENDER_DISCRIMINANT_MEMBER = 1,
    /** <No documentation available> */
    SENDER_DISCRIMINANT_EXTERNAL = 2,
    /** <No documentation available> */
    SENDER_DISCRIMINANT_NEW_MEMBER_PROPOSAL = 3,
    /** <No documentation available> */
    SENDER_DISCRIMINANT_NEW_MEMBER_COMMIT = 4,
}
#ifndef DOXYGEN
; typedef uint8_t
#endif
SenderDiscriminant_t;

/** <No documentation available> */
SenderDiscriminant_t
sender_discriminant (
    Sender_t const * x);

/** <No documentation available> */
void
sender_free (
    Sender_t * _x);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_Sender {
    /** \brief
     *  Pointer to the first element (if any).
     */
    Sender_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_Sender_t;

/** <No documentation available> */
Sender_t const *
sender_slice_get (
    slice_ref_Sender_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_Sender {
    /** \brief
     *  Pointer to the first element (if any).
     */
    Sender_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_Sender_t;

/** <No documentation available> */
Sender_t *
sender_slice_get_mut (
    slice_mut_Sender_t items,
    size_t index);

/** <No documentation available> */
uint32_t const *
sender_to_external (
    Sender_t const * x);

/** <No documentation available> */
uint32_t const *
sender_to_member (
    Sender_t const * x);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_Sender {
    /** <No documentation available> */
    Sender_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_Sender_t;

/** <No documentation available> */
slice_ref_Sender_t
sender_vec_as_slice (
    Vec_Sender_t const * v);

/** <No documentation available> */
slice_mut_Sender_t
sender_vec_as_slice_mut (
    Vec_Sender_t * v);

/** <No documentation available> */
void
sender_vec_free (
    Vec_Sender_t _v);

/** <No documentation available> */
Vec_Sender_t
sender_vec_new (void);

/** <No documentation available> */
void
sender_vec_push (
    Vec_Sender_t * v,
    Sender_t * item);

/** <No documentation available> */
void
signature_keypair_free (
    SignatureKeypair_t * _x);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_SignatureKeypair {
    /** \brief
     *  Pointer to the first element (if any).
     */
    SignatureKeypair_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_SignatureKeypair_t;

/** <No documentation available> */
SignatureKeypair_t const *
signature_keypair_slice_get (
    slice_ref_SignatureKeypair_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_SignatureKeypair {
    /** \brief
     *  Pointer to the first element (if any).
     */
    SignatureKeypair_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_SignatureKeypair_t;

/** <No documentation available> */
SignatureKeypair_t *
signature_keypair_slice_get_mut (
    slice_mut_SignatureKeypair_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_SignatureKeypair {
    /** <No documentation available> */
    SignatureKeypair_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_SignatureKeypair_t;

/** <No documentation available> */
slice_ref_SignatureKeypair_t
signature_keypair_vec_as_slice (
    Vec_SignatureKeypair_t const * v);

/** <No documentation available> */
slice_mut_SignatureKeypair_t
signature_keypair_vec_as_slice_mut (
    Vec_SignatureKeypair_t * v);

/** <No documentation available> */
void
signature_keypair_vec_free (
    Vec_SignatureKeypair_t _v);

/** <No documentation available> */
Vec_SignatureKeypair_t
signature_keypair_vec_new (void);

/** <No documentation available> */
void
signature_keypair_vec_push (
    Vec_SignatureKeypair_t * v,
    SignatureKeypair_t * item);

/** \brief
 *  Byte representation of a signature public key. For ciphersuites using elliptic curves,
 *  the public key should be represented in the uncompressed format.
 */
typedef struct SignaturePublicKey SignaturePublicKey_t;

/** <No documentation available> */
slice_ref_uint8_t
signature_public_key_as_bytes (
    SignaturePublicKey_t const * __safer_ffi_gen_self);

/** <No documentation available> */
void
signature_public_key_free (
    SignaturePublicKey_t * _x);

/** <No documentation available> */
SignaturePublicKey_t *
signature_public_key_new (
    Vec_uint8_t bytes);

/** <No documentation available> */
SignaturePublicKey_t *
signature_public_key_new_slice (
    slice_ref_uint8_t data);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_SignaturePublicKey {
    /** \brief
     *  Pointer to the first element (if any).
     */
    SignaturePublicKey_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_SignaturePublicKey_t;

/** <No documentation available> */
SignaturePublicKey_t const *
signature_public_key_slice_get (
    slice_ref_SignaturePublicKey_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_SignaturePublicKey {
    /** \brief
     *  Pointer to the first element (if any).
     */
    SignaturePublicKey_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_SignaturePublicKey_t;

/** <No documentation available> */
SignaturePublicKey_t *
signature_public_key_slice_get_mut (
    slice_mut_SignaturePublicKey_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_SignaturePublicKey {
    /** <No documentation available> */
    SignaturePublicKey_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_SignaturePublicKey_t;

/** <No documentation available> */
slice_ref_SignaturePublicKey_t
signature_public_key_vec_as_slice (
    Vec_SignaturePublicKey_t const * v);

/** <No documentation available> */
slice_mut_SignaturePublicKey_t
signature_public_key_vec_as_slice_mut (
    Vec_SignaturePublicKey_t * v);

/** <No documentation available> */
void
signature_public_key_vec_free (
    Vec_SignaturePublicKey_t _v);

/** <No documentation available> */
Vec_SignaturePublicKey_t
signature_public_key_vec_new (void);

/** <No documentation available> */
void
signature_public_key_vec_push (
    Vec_SignaturePublicKey_t * v,
    SignaturePublicKey_t * item);

/** \brief
 *  Byte representation of a signature key.
 */
typedef struct SignatureSecretKey SignatureSecretKey_t;

/** <No documentation available> */
slice_ref_uint8_t
signature_secret_key_as_bytes (
    SignatureSecretKey_t const * __safer_ffi_gen_self);

/** <No documentation available> */
SignatureSecretKey_t *
signature_secret_key_clone (
    SignatureSecretKey_t const * x);

/** <No documentation available> */
void
signature_secret_key_free (
    SignatureSecretKey_t * _x);

/** <No documentation available> */
SignatureSecretKey_t *
signature_secret_key_new (
    Vec_uint8_t bytes);

/** <No documentation available> */
SignatureSecretKey_t *
signature_secret_key_new_slice (
    slice_ref_uint8_t data);

/** \brief
 *  `&'lt [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_ref_SignatureSecretKey {
    /** \brief
     *  Pointer to the first element (if any).
     */
    SignatureSecretKey_t const * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_ref_SignatureSecretKey_t;

/** <No documentation available> */
SignatureSecretKey_t const *
signature_secret_key_slice_get (
    slice_ref_SignatureSecretKey_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_SignatureSecretKey {
    /** \brief
     *  Pointer to the first element (if any).
     */
    SignatureSecretKey_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_SignatureSecretKey_t;

/** <No documentation available> */
SignatureSecretKey_t *
signature_secret_key_slice_get_mut (
    slice_mut_SignatureSecretKey_t items,
    size_t index);

/** \brief
 *  Same as [`Vec<T>`][`rust::Vec`], but with guaranteed `#[repr(C)]` layout
 */
typedef struct Vec_SignatureSecretKey {
    /** <No documentation available> */
    SignatureSecretKey_t * ptr;

    /** <No documentation available> */
    size_t len;

    /** <No documentation available> */
    size_t cap;
} Vec_SignatureSecretKey_t;

/** <No documentation available> */
slice_ref_SignatureSecretKey_t
signature_secret_key_vec_as_slice (
    Vec_SignatureSecretKey_t const * v);

/** <No documentation available> */
slice_mut_SignatureSecretKey_t
signature_secret_key_vec_as_slice_mut (
    Vec_SignatureSecretKey_t * v);

/** <No documentation available> */
void
signature_secret_key_vec_free (
    Vec_SignatureSecretKey_t _v);

/** <No documentation available> */
Vec_SignatureSecretKey_t
signature_secret_key_vec_new (void);

/** <No documentation available> */
void
signature_secret_key_vec_push (
    Vec_SignatureSecretKey_t * v,
    SignatureSecretKey_t * item);

/** <No documentation available> */
SigningIdentity_t *
signing_identity_clone (
    SigningIdentity_t const * x);

/** <No documentation available> */
void
signing_identity_free (
    SigningIdentity_t * _x);

/** <No documentation available> */
SigningIdentity_t const *
signing_identity_slice_get (
    slice_ref_SigningIdentity_t items,
    size_t index);

/** \brief
 *  `&'lt mut [T]` but with a guaranteed `#[repr(C)]` layout.
 *
 *  # C layout (for some given type T)
 *
 *  ```c
 *  typedef struct {
 *  // Cannot be NULL
 *  T * ptr;
 *  size_t len;
 *  } slice_T;
 *  ```
 *
 *  # Nullable pointer?
 *
 *  If you want to support the above typedef, but where the `ptr` field is
 *  allowed to be `NULL` (with the contents of `len` then being undefined)
 *  use the `Option< slice_ptr<_> >` type.
 */
typedef struct slice_mut_SigningIdentity {
    /** \brief
     *  Pointer to the first element (if any).
     */
    SigningIdentity_t * ptr;

    /** \brief
     *  Element count
     */
    size_t len;
} slice_mut_SigningIdentity_t;

/** <No documentation available> */
SigningIdentity_t *
signing_identity_slice_get_mut (
    slice_mut_SigningIdentity_t items,
    size_t index);

/** <No documentation available> */
slice_ref_SigningIdentity_t
signing_identity_vec_as_slice (
    Vec_SigningIdentity_t const * v);

/** <No documentation available> */
slice_mut_SigningIdentity_t
signing_identity_vec_as_slice_mut (
    Vec_SigningIdentity_t * v);

/** <No documentation available> */
void
signing_identity_vec_free (
    Vec_SigningIdentity_t _v);

/** <No documentation available> */
Vec_SigningIdentity_t
signing_identity_vec_new (void);

/** <No documentation available> */
void
signing_identity_vec_push (
    Vec_SigningIdentity_t * v,
    SigningIdentity_t * item);

/** <No documentation available> */
void
vec_u8_free (
    Vec_uint8_t _v);

/** <No documentation available> */
Vec_uint8_t
vec_u8_from_slice (
    slice_ref_uint8_t bytes);

/** <No documentation available> */
Vec_uint8_t
vec_u8_new (
    size_t length);

/** <No documentation available> */
void
wire_format_free (
    WireFormat_t _x);


#ifdef __cplusplus
} /* extern \"C\" */
#endif

#endif /* __RUST_MLS_LITE__ */
